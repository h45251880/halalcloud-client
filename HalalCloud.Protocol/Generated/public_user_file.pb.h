// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: public_user_file.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_public_5fuser_5ffile_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_public_5fuser_5ffile_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "pub_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_public_5fuser_5ffile_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_public_5fuser_5ffile_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_public_5fuser_5ffile_2eproto;
namespace v6 {
namespace services {
namespace pub {
class BatchOperationRequest;
struct BatchOperationRequestDefaultTypeInternal;
extern BatchOperationRequestDefaultTypeInternal _BatchOperationRequest_default_instance_;
class BatchOperationResponse;
struct BatchOperationResponseDefaultTypeInternal;
extern BatchOperationResponseDefaultTypeInternal _BatchOperationResponse_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FileListRequest;
struct FileListRequestDefaultTypeInternal;
extern FileListRequestDefaultTypeInternal _FileListRequest_default_instance_;
class FileListResponse;
struct FileListResponseDefaultTypeInternal;
extern FileListResponseDefaultTypeInternal _FileListResponse_default_instance_;
class GetIceCandidateRequest;
struct GetIceCandidateRequestDefaultTypeInternal;
extern GetIceCandidateRequestDefaultTypeInternal _GetIceCandidateRequest_default_instance_;
class GetIceCandidateResponse;
struct GetIceCandidateResponseDefaultTypeInternal;
extern GetIceCandidateResponseDefaultTypeInternal _GetIceCandidateResponse_default_instance_;
class ManageRTCRequest;
struct ManageRTCRequestDefaultTypeInternal;
extern ManageRTCRequestDefaultTypeInternal _ManageRTCRequest_default_instance_;
class ManageRTCResponse;
struct ManageRTCResponseDefaultTypeInternal;
extern ManageRTCResponseDefaultTypeInternal _ManageRTCResponse_default_instance_;
class ParseFileSliceResponse;
struct ParseFileSliceResponseDefaultTypeInternal;
extern ParseFileSliceResponseDefaultTypeInternal _ParseFileSliceResponse_default_instance_;
class SearchRequest;
struct SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class SendIceCandidateRequest;
struct SendIceCandidateRequestDefaultTypeInternal;
extern SendIceCandidateRequestDefaultTypeInternal _SendIceCandidateRequest_default_instance_;
class SendIceCandidateResponse;
struct SendIceCandidateResponseDefaultTypeInternal;
extern SendIceCandidateResponseDefaultTypeInternal _SendIceCandidateResponse_default_instance_;
class SliceDownloadAddressRequest;
struct SliceDownloadAddressRequestDefaultTypeInternal;
extern SliceDownloadAddressRequestDefaultTypeInternal _SliceDownloadAddressRequest_default_instance_;
class SliceDownloadAddressResponse;
struct SliceDownloadAddressResponseDefaultTypeInternal;
extern SliceDownloadAddressResponseDefaultTypeInternal _SliceDownloadAddressResponse_default_instance_;
class SliceDownloadInfo;
struct SliceDownloadInfoDefaultTypeInternal;
extern SliceDownloadInfoDefaultTypeInternal _SliceDownloadInfo_default_instance_;
class SliceSize;
struct SliceSizeDefaultTypeInternal;
extern SliceSizeDefaultTypeInternal _SliceSize_default_instance_;
}  // namespace pub
}  // namespace services
}  // namespace v6
PROTOBUF_NAMESPACE_OPEN
template<> ::v6::services::pub::BatchOperationRequest* Arena::CreateMaybeMessage<::v6::services::pub::BatchOperationRequest>(Arena*);
template<> ::v6::services::pub::BatchOperationResponse* Arena::CreateMaybeMessage<::v6::services::pub::BatchOperationResponse>(Arena*);
template<> ::v6::services::pub::File* Arena::CreateMaybeMessage<::v6::services::pub::File>(Arena*);
template<> ::v6::services::pub::FileListRequest* Arena::CreateMaybeMessage<::v6::services::pub::FileListRequest>(Arena*);
template<> ::v6::services::pub::FileListResponse* Arena::CreateMaybeMessage<::v6::services::pub::FileListResponse>(Arena*);
template<> ::v6::services::pub::GetIceCandidateRequest* Arena::CreateMaybeMessage<::v6::services::pub::GetIceCandidateRequest>(Arena*);
template<> ::v6::services::pub::GetIceCandidateResponse* Arena::CreateMaybeMessage<::v6::services::pub::GetIceCandidateResponse>(Arena*);
template<> ::v6::services::pub::ManageRTCRequest* Arena::CreateMaybeMessage<::v6::services::pub::ManageRTCRequest>(Arena*);
template<> ::v6::services::pub::ManageRTCResponse* Arena::CreateMaybeMessage<::v6::services::pub::ManageRTCResponse>(Arena*);
template<> ::v6::services::pub::ParseFileSliceResponse* Arena::CreateMaybeMessage<::v6::services::pub::ParseFileSliceResponse>(Arena*);
template<> ::v6::services::pub::SearchRequest* Arena::CreateMaybeMessage<::v6::services::pub::SearchRequest>(Arena*);
template<> ::v6::services::pub::SendIceCandidateRequest* Arena::CreateMaybeMessage<::v6::services::pub::SendIceCandidateRequest>(Arena*);
template<> ::v6::services::pub::SendIceCandidateResponse* Arena::CreateMaybeMessage<::v6::services::pub::SendIceCandidateResponse>(Arena*);
template<> ::v6::services::pub::SliceDownloadAddressRequest* Arena::CreateMaybeMessage<::v6::services::pub::SliceDownloadAddressRequest>(Arena*);
template<> ::v6::services::pub::SliceDownloadAddressResponse* Arena::CreateMaybeMessage<::v6::services::pub::SliceDownloadAddressResponse>(Arena*);
template<> ::v6::services::pub::SliceDownloadInfo* Arena::CreateMaybeMessage<::v6::services::pub::SliceDownloadInfo>(Arena*);
template<> ::v6::services::pub::SliceSize* Arena::CreateMaybeMessage<::v6::services::pub::SliceSize>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v6 {
namespace services {
namespace pub {

// ===================================================================

class File final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit PROTOBUF_CONSTEXPR File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<File>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const File& from) {
    File::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kParentFieldNumber = 3,
    kNameFieldNumber = 4,
    kPathFieldNumber = 5,
    kMimeTypeFieldNumber = 6,
    kLockedByFieldNumber = 20,
    kUniqueFieldNumber = 23,
    kContentIdentityFieldNumber = 24,
    kSizeFieldNumber = 7,
    kTypeFieldNumber = 8,
    kCreatedAtFieldNumber = 9,
    kUpdatedAtFieldNumber = 10,
    kDeletedAtFieldNumber = 11,
    kDeletedFieldNumber = 12,
    kDirFieldNumber = 13,
    kHiddenFieldNumber = 14,
    kLockedFieldNumber = 15,
    kSharedFieldNumber = 16,
    kStarredFieldNumber = 17,
    kTrashedFieldNumber = 18,
    kLockedAtFieldNumber = 19,
    kSharedAtFieldNumber = 21,
    kFlagFieldNumber = 22,
    kLabelFieldNumber = 25,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string parent = 3;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string path = 5;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string mime_type = 6;
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // string locked_by = 20;
  void clear_locked_by();
  const std::string& locked_by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locked_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locked_by();
  PROTOBUF_NODISCARD std::string* release_locked_by();
  void set_allocated_locked_by(std::string* locked_by);
  private:
  const std::string& _internal_locked_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locked_by(const std::string& value);
  std::string* _internal_mutable_locked_by();
  public:

  // string unique = 23;
  void clear_unique();
  const std::string& unique() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique();
  PROTOBUF_NODISCARD std::string* release_unique();
  void set_allocated_unique(std::string* unique);
  private:
  const std::string& _internal_unique() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique(const std::string& value);
  std::string* _internal_mutable_unique();
  public:

  // string content_identity = 24;
  void clear_content_identity();
  const std::string& content_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_identity();
  PROTOBUF_NODISCARD std::string* release_content_identity();
  void set_allocated_content_identity(std::string* content_identity);
  private:
  const std::string& _internal_content_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_identity(const std::string& value);
  std::string* _internal_mutable_content_identity();
  public:

  // int64 size = 7;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int64 type = 8;
  void clear_type();
  int64_t type() const;
  void set_type(int64_t value);
  private:
  int64_t _internal_type() const;
  void _internal_set_type(int64_t value);
  public:

  // int64 created_at = 9;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 updated_at = 10;
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // int64 deleted_at = 11;
  void clear_deleted_at();
  int64_t deleted_at() const;
  void set_deleted_at(int64_t value);
  private:
  int64_t _internal_deleted_at() const;
  void _internal_set_deleted_at(int64_t value);
  public:

  // bool deleted = 12;
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // bool dir = 13;
  void clear_dir();
  bool dir() const;
  void set_dir(bool value);
  private:
  bool _internal_dir() const;
  void _internal_set_dir(bool value);
  public:

  // bool hidden = 14;
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // bool locked = 15;
  void clear_locked();
  bool locked() const;
  void set_locked(bool value);
  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);
  public:

  // bool shared = 16;
  void clear_shared();
  bool shared() const;
  void set_shared(bool value);
  private:
  bool _internal_shared() const;
  void _internal_set_shared(bool value);
  public:

  // bool starred = 17;
  void clear_starred();
  bool starred() const;
  void set_starred(bool value);
  private:
  bool _internal_starred() const;
  void _internal_set_starred(bool value);
  public:

  // bool trashed = 18;
  void clear_trashed();
  bool trashed() const;
  void set_trashed(bool value);
  private:
  bool _internal_trashed() const;
  void _internal_set_trashed(bool value);
  public:

  // int64 locked_at = 19;
  void clear_locked_at();
  int64_t locked_at() const;
  void set_locked_at(int64_t value);
  private:
  int64_t _internal_locked_at() const;
  void _internal_set_locked_at(int64_t value);
  public:

  // int64 shared_at = 21;
  void clear_shared_at();
  int64_t shared_at() const;
  void set_shared_at(int64_t value);
  private:
  int64_t _internal_shared_at() const;
  void _internal_set_shared_at(int64_t value);
  public:

  // int64 flag = 22;
  void clear_flag();
  int64_t flag() const;
  void set_flag(int64_t value);
  private:
  int64_t _internal_flag() const;
  void _internal_set_flag(int64_t value);
  public:

  // int64 label = 25;
  void clear_label();
  int64_t label() const;
  void set_label(int64_t value);
  private:
  int64_t _internal_label() const;
  void _internal_set_label(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locked_by_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_identity_;
    int64_t size_;
    int64_t type_;
    int64_t created_at_;
    int64_t updated_at_;
    int64_t deleted_at_;
    bool deleted_;
    bool dir_;
    bool hidden_;
    bool locked_;
    bool shared_;
    bool starred_;
    bool trashed_;
    int64_t locked_at_;
    int64_t shared_at_;
    int64_t flag_;
    int64_t label_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class FileListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.FileListRequest) */ {
 public:
  inline FileListRequest() : FileListRequest(nullptr) {}
  ~FileListRequest() override;
  explicit PROTOBUF_CONSTEXPR FileListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileListRequest(const FileListRequest& from);
  FileListRequest(FileListRequest&& from) noexcept
    : FileListRequest() {
    *this = ::std::move(from);
  }

  inline FileListRequest& operator=(const FileListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileListRequest& operator=(FileListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileListRequest* internal_default_instance() {
    return reinterpret_cast<const FileListRequest*>(
               &_FileListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FileListRequest& a, FileListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FileListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileListRequest& from) {
    FileListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.FileListRequest";
  }
  protected:
  explicit FileListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kFilterFieldNumber = 2,
    kListInfoFieldNumber = 3,
  };
  // .v6.services.pub.File parent = 1;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::v6::services::pub::File& parent() const;
  PROTOBUF_NODISCARD ::v6::services::pub::File* release_parent();
  ::v6::services::pub::File* mutable_parent();
  void set_allocated_parent(::v6::services::pub::File* parent);
  private:
  const ::v6::services::pub::File& _internal_parent() const;
  ::v6::services::pub::File* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::v6::services::pub::File* parent);
  ::v6::services::pub::File* unsafe_arena_release_parent();

  // .v6.services.pub.File filter = 2;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::v6::services::pub::File& filter() const;
  PROTOBUF_NODISCARD ::v6::services::pub::File* release_filter();
  ::v6::services::pub::File* mutable_filter();
  void set_allocated_filter(::v6::services::pub::File* filter);
  private:
  const ::v6::services::pub::File& _internal_filter() const;
  ::v6::services::pub::File* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::v6::services::pub::File* filter);
  ::v6::services::pub::File* unsafe_arena_release_filter();

  // .v6.services.pub.common.ScanListRequest list_info = 3;
  bool has_list_info() const;
  private:
  bool _internal_has_list_info() const;
  public:
  void clear_list_info();
  const ::v6::services::pub::common::ScanListRequest& list_info() const;
  PROTOBUF_NODISCARD ::v6::services::pub::common::ScanListRequest* release_list_info();
  ::v6::services::pub::common::ScanListRequest* mutable_list_info();
  void set_allocated_list_info(::v6::services::pub::common::ScanListRequest* list_info);
  private:
  const ::v6::services::pub::common::ScanListRequest& _internal_list_info() const;
  ::v6::services::pub::common::ScanListRequest* _internal_mutable_list_info();
  public:
  void unsafe_arena_set_allocated_list_info(
      ::v6::services::pub::common::ScanListRequest* list_info);
  ::v6::services::pub::common::ScanListRequest* unsafe_arena_release_list_info();

  // @@protoc_insertion_point(class_scope:v6.services.pub.FileListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::v6::services::pub::File* parent_;
    ::v6::services::pub::File* filter_;
    ::v6::services::pub::common::ScanListRequest* list_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SearchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {}
  ~SearchRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchRequest(const SearchRequest& from);
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchRequest& from) {
    SearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SearchRequest";
  }
  protected:
  explicit SearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kListInfoFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .v6.services.pub.common.ScanListRequest list_info = 3;
  bool has_list_info() const;
  private:
  bool _internal_has_list_info() const;
  public:
  void clear_list_info();
  const ::v6::services::pub::common::ScanListRequest& list_info() const;
  PROTOBUF_NODISCARD ::v6::services::pub::common::ScanListRequest* release_list_info();
  ::v6::services::pub::common::ScanListRequest* mutable_list_info();
  void set_allocated_list_info(::v6::services::pub::common::ScanListRequest* list_info);
  private:
  const ::v6::services::pub::common::ScanListRequest& _internal_list_info() const;
  ::v6::services::pub::common::ScanListRequest* _internal_mutable_list_info();
  public:
  void unsafe_arena_set_allocated_list_info(
      ::v6::services::pub::common::ScanListRequest* list_info);
  ::v6::services::pub::common::ScanListRequest* unsafe_arena_release_list_info();

  // @@protoc_insertion_point(class_scope:v6.services.pub.SearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::v6::services::pub::common::ScanListRequest* list_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class FileListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.FileListResponse) */ {
 public:
  inline FileListResponse() : FileListResponse(nullptr) {}
  ~FileListResponse() override;
  explicit PROTOBUF_CONSTEXPR FileListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileListResponse(const FileListResponse& from);
  FileListResponse(FileListResponse&& from) noexcept
    : FileListResponse() {
    *this = ::std::move(from);
  }

  inline FileListResponse& operator=(const FileListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileListResponse& operator=(FileListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileListResponse* internal_default_instance() {
    return reinterpret_cast<const FileListResponse*>(
               &_FileListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileListResponse& a, FileListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FileListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileListResponse& from) {
    FileListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.FileListResponse";
  }
  protected:
  explicit FileListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 1,
    kListInfoFieldNumber = 2,
  };
  // repeated .v6.services.pub.File files = 1;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::v6::services::pub::File* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >*
      mutable_files();
  private:
  const ::v6::services::pub::File& _internal_files(int index) const;
  ::v6::services::pub::File* _internal_add_files();
  public:
  const ::v6::services::pub::File& files(int index) const;
  ::v6::services::pub::File* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >&
      files() const;

  // .v6.services.pub.common.ScanListRequest list_info = 2;
  bool has_list_info() const;
  private:
  bool _internal_has_list_info() const;
  public:
  void clear_list_info();
  const ::v6::services::pub::common::ScanListRequest& list_info() const;
  PROTOBUF_NODISCARD ::v6::services::pub::common::ScanListRequest* release_list_info();
  ::v6::services::pub::common::ScanListRequest* mutable_list_info();
  void set_allocated_list_info(::v6::services::pub::common::ScanListRequest* list_info);
  private:
  const ::v6::services::pub::common::ScanListRequest& _internal_list_info() const;
  ::v6::services::pub::common::ScanListRequest* _internal_mutable_list_info();
  public:
  void unsafe_arena_set_allocated_list_info(
      ::v6::services::pub::common::ScanListRequest* list_info);
  ::v6::services::pub::common::ScanListRequest* unsafe_arena_release_list_info();

  // @@protoc_insertion_point(class_scope:v6.services.pub.FileListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File > files_;
    ::v6::services::pub::common::ScanListRequest* list_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class BatchOperationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.BatchOperationRequest) */ {
 public:
  inline BatchOperationRequest() : BatchOperationRequest(nullptr) {}
  ~BatchOperationRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchOperationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchOperationRequest(const BatchOperationRequest& from);
  BatchOperationRequest(BatchOperationRequest&& from) noexcept
    : BatchOperationRequest() {
    *this = ::std::move(from);
  }

  inline BatchOperationRequest& operator=(const BatchOperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchOperationRequest& operator=(BatchOperationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchOperationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchOperationRequest* internal_default_instance() {
    return reinterpret_cast<const BatchOperationRequest*>(
               &_BatchOperationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BatchOperationRequest& a, BatchOperationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchOperationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchOperationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchOperationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchOperationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchOperationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchOperationRequest& from) {
    BatchOperationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchOperationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.BatchOperationRequest";
  }
  protected:
  explicit BatchOperationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kDestFieldNumber = 2,
    kOperationFieldNumber = 3,
    kFlagFieldNumber = 4,
  };
  // repeated .v6.services.pub.File source = 1;
  int source_size() const;
  private:
  int _internal_source_size() const;
  public:
  void clear_source();
  ::v6::services::pub::File* mutable_source(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >*
      mutable_source();
  private:
  const ::v6::services::pub::File& _internal_source(int index) const;
  ::v6::services::pub::File* _internal_add_source();
  public:
  const ::v6::services::pub::File& source(int index) const;
  ::v6::services::pub::File* add_source();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >&
      source() const;

  // .v6.services.pub.File dest = 2;
  bool has_dest() const;
  private:
  bool _internal_has_dest() const;
  public:
  void clear_dest();
  const ::v6::services::pub::File& dest() const;
  PROTOBUF_NODISCARD ::v6::services::pub::File* release_dest();
  ::v6::services::pub::File* mutable_dest();
  void set_allocated_dest(::v6::services::pub::File* dest);
  private:
  const ::v6::services::pub::File& _internal_dest() const;
  ::v6::services::pub::File* _internal_mutable_dest();
  public:
  void unsafe_arena_set_allocated_dest(
      ::v6::services::pub::File* dest);
  ::v6::services::pub::File* unsafe_arena_release_dest();

  // int32 operation = 3;
  void clear_operation();
  int32_t operation() const;
  void set_operation(int32_t value);
  private:
  int32_t _internal_operation() const;
  void _internal_set_operation(int32_t value);
  public:

  // int32 flag = 4;
  void clear_flag();
  int32_t flag() const;
  void set_flag(int32_t value);
  private:
  int32_t _internal_flag() const;
  void _internal_set_flag(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.BatchOperationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File > source_;
    ::v6::services::pub::File* dest_;
    int32_t operation_;
    int32_t flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class BatchOperationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.BatchOperationResponse) */ {
 public:
  inline BatchOperationResponse() : BatchOperationResponse(nullptr) {}
  ~BatchOperationResponse() override;
  explicit PROTOBUF_CONSTEXPR BatchOperationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchOperationResponse(const BatchOperationResponse& from);
  BatchOperationResponse(BatchOperationResponse&& from) noexcept
    : BatchOperationResponse() {
    *this = ::std::move(from);
  }

  inline BatchOperationResponse& operator=(const BatchOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchOperationResponse& operator=(BatchOperationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchOperationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchOperationResponse* internal_default_instance() {
    return reinterpret_cast<const BatchOperationResponse*>(
               &_BatchOperationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BatchOperationResponse& a, BatchOperationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchOperationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchOperationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchOperationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchOperationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchOperationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BatchOperationResponse& from) {
    BatchOperationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchOperationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.BatchOperationResponse";
  }
  protected:
  explicit BatchOperationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 1,
    kAffectedFieldNumber = 3,
    kCreatedAtFieldNumber = 4,
    kProgressFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // string task = 1;
  void clear_task();
  const std::string& task() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // int64 affected = 3;
  void clear_affected();
  int64_t affected() const;
  void set_affected(int64_t value);
  private:
  int64_t _internal_affected() const;
  void _internal_set_affected(int64_t value);
  public:

  // int64 created_at = 4;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 progress = 5;
  void clear_progress();
  int64_t progress() const;
  void set_progress(int64_t value);
  private:
  int64_t _internal_progress() const;
  void _internal_set_progress(int64_t value);
  public:

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.BatchOperationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
    int64_t affected_;
    int64_t created_at_;
    int64_t progress_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class ManageRTCRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.ManageRTCRequest) */ {
 public:
  inline ManageRTCRequest() : ManageRTCRequest(nullptr) {}
  ~ManageRTCRequest() override;
  explicit PROTOBUF_CONSTEXPR ManageRTCRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManageRTCRequest(const ManageRTCRequest& from);
  ManageRTCRequest(ManageRTCRequest&& from) noexcept
    : ManageRTCRequest() {
    *this = ::std::move(from);
  }

  inline ManageRTCRequest& operator=(const ManageRTCRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManageRTCRequest& operator=(ManageRTCRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManageRTCRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManageRTCRequest* internal_default_instance() {
    return reinterpret_cast<const ManageRTCRequest*>(
               &_ManageRTCRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ManageRTCRequest& a, ManageRTCRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ManageRTCRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManageRTCRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManageRTCRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManageRTCRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManageRTCRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManageRTCRequest& from) {
    ManageRTCRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManageRTCRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.ManageRTCRequest";
  }
  protected:
  explicit ManageRTCRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpFieldNumber = 1,
    kOfferFieldNumber = 2,
    kClientIdentityFieldNumber = 3,
  };
  // string sdp = 1;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // string offer = 2;
  void clear_offer();
  const std::string& offer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_offer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_offer();
  PROTOBUF_NODISCARD std::string* release_offer();
  void set_allocated_offer(std::string* offer);
  private:
  const std::string& _internal_offer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offer(const std::string& value);
  std::string* _internal_mutable_offer();
  public:

  // string client_identity = 3;
  void clear_client_identity();
  const std::string& client_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_identity();
  PROTOBUF_NODISCARD std::string* release_client_identity();
  void set_allocated_client_identity(std::string* client_identity);
  private:
  const std::string& _internal_client_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_identity(const std::string& value);
  std::string* _internal_mutable_client_identity();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.ManageRTCRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class ManageRTCResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.ManageRTCResponse) */ {
 public:
  inline ManageRTCResponse() : ManageRTCResponse(nullptr) {}
  ~ManageRTCResponse() override;
  explicit PROTOBUF_CONSTEXPR ManageRTCResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManageRTCResponse(const ManageRTCResponse& from);
  ManageRTCResponse(ManageRTCResponse&& from) noexcept
    : ManageRTCResponse() {
    *this = ::std::move(from);
  }

  inline ManageRTCResponse& operator=(const ManageRTCResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManageRTCResponse& operator=(ManageRTCResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManageRTCResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManageRTCResponse* internal_default_instance() {
    return reinterpret_cast<const ManageRTCResponse*>(
               &_ManageRTCResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ManageRTCResponse& a, ManageRTCResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ManageRTCResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManageRTCResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManageRTCResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManageRTCResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManageRTCResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManageRTCResponse& from) {
    ManageRTCResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManageRTCResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.ManageRTCResponse";
  }
  protected:
  explicit ManageRTCResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncodeKeyFieldNumber = 2,
    kSdpFieldNumber = 3,
    kNameFieldNumber = 4,
    kConnectionFieldNumber = 5,
    kFileSizeFieldNumber = 1,
  };
  // string encode_key = 2;
  void clear_encode_key();
  const std::string& encode_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encode_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encode_key();
  PROTOBUF_NODISCARD std::string* release_encode_key();
  void set_allocated_encode_key(std::string* encode_key);
  private:
  const std::string& _internal_encode_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encode_key(const std::string& value);
  std::string* _internal_mutable_encode_key();
  public:

  // string sdp = 3;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string connection = 5;
  void clear_connection();
  const std::string& connection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection();
  PROTOBUF_NODISCARD std::string* release_connection();
  void set_allocated_connection(std::string* connection);
  private:
  const std::string& _internal_connection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection(const std::string& value);
  std::string* _internal_mutable_connection();
  public:

  // int64 file_size = 1;
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.ManageRTCResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encode_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_;
    int64_t file_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SendIceCandidateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SendIceCandidateRequest) */ {
 public:
  inline SendIceCandidateRequest() : SendIceCandidateRequest(nullptr) {}
  ~SendIceCandidateRequest() override;
  explicit PROTOBUF_CONSTEXPR SendIceCandidateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendIceCandidateRequest(const SendIceCandidateRequest& from);
  SendIceCandidateRequest(SendIceCandidateRequest&& from) noexcept
    : SendIceCandidateRequest() {
    *this = ::std::move(from);
  }

  inline SendIceCandidateRequest& operator=(const SendIceCandidateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendIceCandidateRequest& operator=(SendIceCandidateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendIceCandidateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendIceCandidateRequest* internal_default_instance() {
    return reinterpret_cast<const SendIceCandidateRequest*>(
               &_SendIceCandidateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SendIceCandidateRequest& a, SendIceCandidateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendIceCandidateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendIceCandidateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendIceCandidateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendIceCandidateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendIceCandidateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendIceCandidateRequest& from) {
    SendIceCandidateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendIceCandidateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SendIceCandidateRequest";
  }
  protected:
  explicit SendIceCandidateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdentityFieldNumber = 1,
    kCandidateFieldNumber = 2,
  };
  // string client_identity = 1;
  void clear_client_identity();
  const std::string& client_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_identity();
  PROTOBUF_NODISCARD std::string* release_client_identity();
  void set_allocated_client_identity(std::string* client_identity);
  private:
  const std::string& _internal_client_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_identity(const std::string& value);
  std::string* _internal_mutable_client_identity();
  public:

  // string candidate = 2;
  void clear_candidate();
  const std::string& candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* candidate);
  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(const std::string& value);
  std::string* _internal_mutable_candidate();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SendIceCandidateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SendIceCandidateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SendIceCandidateResponse) */ {
 public:
  inline SendIceCandidateResponse() : SendIceCandidateResponse(nullptr) {}
  ~SendIceCandidateResponse() override;
  explicit PROTOBUF_CONSTEXPR SendIceCandidateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendIceCandidateResponse(const SendIceCandidateResponse& from);
  SendIceCandidateResponse(SendIceCandidateResponse&& from) noexcept
    : SendIceCandidateResponse() {
    *this = ::std::move(from);
  }

  inline SendIceCandidateResponse& operator=(const SendIceCandidateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendIceCandidateResponse& operator=(SendIceCandidateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendIceCandidateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendIceCandidateResponse* internal_default_instance() {
    return reinterpret_cast<const SendIceCandidateResponse*>(
               &_SendIceCandidateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SendIceCandidateResponse& a, SendIceCandidateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendIceCandidateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendIceCandidateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendIceCandidateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendIceCandidateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendIceCandidateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendIceCandidateResponse& from) {
    SendIceCandidateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendIceCandidateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SendIceCandidateResponse";
  }
  protected:
  explicit SendIceCandidateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdentityFieldNumber = 1,
    kCandidateFieldNumber = 2,
  };
  // string client_identity = 1;
  void clear_client_identity();
  const std::string& client_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_identity();
  PROTOBUF_NODISCARD std::string* release_client_identity();
  void set_allocated_client_identity(std::string* client_identity);
  private:
  const std::string& _internal_client_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_identity(const std::string& value);
  std::string* _internal_mutable_client_identity();
  public:

  // string candidate = 2;
  void clear_candidate();
  const std::string& candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* candidate);
  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(const std::string& value);
  std::string* _internal_mutable_candidate();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SendIceCandidateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class GetIceCandidateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.GetIceCandidateRequest) */ {
 public:
  inline GetIceCandidateRequest() : GetIceCandidateRequest(nullptr) {}
  ~GetIceCandidateRequest() override;
  explicit PROTOBUF_CONSTEXPR GetIceCandidateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIceCandidateRequest(const GetIceCandidateRequest& from);
  GetIceCandidateRequest(GetIceCandidateRequest&& from) noexcept
    : GetIceCandidateRequest() {
    *this = ::std::move(from);
  }

  inline GetIceCandidateRequest& operator=(const GetIceCandidateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIceCandidateRequest& operator=(GetIceCandidateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIceCandidateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIceCandidateRequest* internal_default_instance() {
    return reinterpret_cast<const GetIceCandidateRequest*>(
               &_GetIceCandidateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetIceCandidateRequest& a, GetIceCandidateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIceCandidateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIceCandidateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIceCandidateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIceCandidateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIceCandidateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetIceCandidateRequest& from) {
    GetIceCandidateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIceCandidateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.GetIceCandidateRequest";
  }
  protected:
  explicit GetIceCandidateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdentityFieldNumber = 1,
    kCandidateFieldNumber = 2,
  };
  // string client_identity = 1;
  void clear_client_identity();
  const std::string& client_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_identity();
  PROTOBUF_NODISCARD std::string* release_client_identity();
  void set_allocated_client_identity(std::string* client_identity);
  private:
  const std::string& _internal_client_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_identity(const std::string& value);
  std::string* _internal_mutable_client_identity();
  public:

  // string candidate = 2;
  void clear_candidate();
  const std::string& candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* candidate);
  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(const std::string& value);
  std::string* _internal_mutable_candidate();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.GetIceCandidateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class GetIceCandidateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.GetIceCandidateResponse) */ {
 public:
  inline GetIceCandidateResponse() : GetIceCandidateResponse(nullptr) {}
  ~GetIceCandidateResponse() override;
  explicit PROTOBUF_CONSTEXPR GetIceCandidateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetIceCandidateResponse(const GetIceCandidateResponse& from);
  GetIceCandidateResponse(GetIceCandidateResponse&& from) noexcept
    : GetIceCandidateResponse() {
    *this = ::std::move(from);
  }

  inline GetIceCandidateResponse& operator=(const GetIceCandidateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIceCandidateResponse& operator=(GetIceCandidateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIceCandidateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIceCandidateResponse* internal_default_instance() {
    return reinterpret_cast<const GetIceCandidateResponse*>(
               &_GetIceCandidateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetIceCandidateResponse& a, GetIceCandidateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIceCandidateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIceCandidateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIceCandidateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIceCandidateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetIceCandidateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetIceCandidateResponse& from) {
    GetIceCandidateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIceCandidateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.GetIceCandidateResponse";
  }
  protected:
  explicit GetIceCandidateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidateFieldNumber = 2,
    kClientIdentityFieldNumber = 1,
  };
  // repeated string candidate = 2;
  int candidate_size() const;
  private:
  int _internal_candidate_size() const;
  public:
  void clear_candidate();
  const std::string& candidate(int index) const;
  std::string* mutable_candidate(int index);
  void set_candidate(int index, const std::string& value);
  void set_candidate(int index, std::string&& value);
  void set_candidate(int index, const char* value);
  void set_candidate(int index, const char* value, size_t size);
  std::string* add_candidate();
  void add_candidate(const std::string& value);
  void add_candidate(std::string&& value);
  void add_candidate(const char* value);
  void add_candidate(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& candidate() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_candidate();
  private:
  const std::string& _internal_candidate(int index) const;
  std::string* _internal_add_candidate();
  public:

  // string client_identity = 1;
  void clear_client_identity();
  const std::string& client_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_identity();
  PROTOBUF_NODISCARD std::string* release_client_identity();
  void set_allocated_client_identity(std::string* client_identity);
  private:
  const std::string& _internal_client_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_identity(const std::string& value);
  std::string* _internal_mutable_client_identity();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.GetIceCandidateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> candidate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class ParseFileSliceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.ParseFileSliceResponse) */ {
 public:
  inline ParseFileSliceResponse() : ParseFileSliceResponse(nullptr) {}
  ~ParseFileSliceResponse() override;
  explicit PROTOBUF_CONSTEXPR ParseFileSliceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParseFileSliceResponse(const ParseFileSliceResponse& from);
  ParseFileSliceResponse(ParseFileSliceResponse&& from) noexcept
    : ParseFileSliceResponse() {
    *this = ::std::move(from);
  }

  inline ParseFileSliceResponse& operator=(const ParseFileSliceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParseFileSliceResponse& operator=(ParseFileSliceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParseFileSliceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParseFileSliceResponse* internal_default_instance() {
    return reinterpret_cast<const ParseFileSliceResponse*>(
               &_ParseFileSliceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ParseFileSliceResponse& a, ParseFileSliceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ParseFileSliceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParseFileSliceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParseFileSliceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParseFileSliceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParseFileSliceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParseFileSliceResponse& from) {
    ParseFileSliceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParseFileSliceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.ParseFileSliceResponse";
  }
  protected:
  explicit ParseFileSliceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaNodesFieldNumber = 2,
    kRawNodesFieldNumber = 3,
    kSizesFieldNumber = 5,
    kContentIdentityFieldNumber = 1,
    kSha1FieldNumber = 6,
    kWcsEtagFieldNumber = 7,
    kFileSizeFieldNumber = 4,
  };
  // repeated string meta_nodes = 2;
  int meta_nodes_size() const;
  private:
  int _internal_meta_nodes_size() const;
  public:
  void clear_meta_nodes();
  const std::string& meta_nodes(int index) const;
  std::string* mutable_meta_nodes(int index);
  void set_meta_nodes(int index, const std::string& value);
  void set_meta_nodes(int index, std::string&& value);
  void set_meta_nodes(int index, const char* value);
  void set_meta_nodes(int index, const char* value, size_t size);
  std::string* add_meta_nodes();
  void add_meta_nodes(const std::string& value);
  void add_meta_nodes(std::string&& value);
  void add_meta_nodes(const char* value);
  void add_meta_nodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& meta_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_meta_nodes();
  private:
  const std::string& _internal_meta_nodes(int index) const;
  std::string* _internal_add_meta_nodes();
  public:

  // repeated string raw_nodes = 3;
  int raw_nodes_size() const;
  private:
  int _internal_raw_nodes_size() const;
  public:
  void clear_raw_nodes();
  const std::string& raw_nodes(int index) const;
  std::string* mutable_raw_nodes(int index);
  void set_raw_nodes(int index, const std::string& value);
  void set_raw_nodes(int index, std::string&& value);
  void set_raw_nodes(int index, const char* value);
  void set_raw_nodes(int index, const char* value, size_t size);
  std::string* add_raw_nodes();
  void add_raw_nodes(const std::string& value);
  void add_raw_nodes(std::string&& value);
  void add_raw_nodes(const char* value);
  void add_raw_nodes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& raw_nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_raw_nodes();
  private:
  const std::string& _internal_raw_nodes(int index) const;
  std::string* _internal_add_raw_nodes();
  public:

  // repeated .v6.services.pub.SliceSize sizes = 5;
  int sizes_size() const;
  private:
  int _internal_sizes_size() const;
  public:
  void clear_sizes();
  ::v6::services::pub::SliceSize* mutable_sizes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceSize >*
      mutable_sizes();
  private:
  const ::v6::services::pub::SliceSize& _internal_sizes(int index) const;
  ::v6::services::pub::SliceSize* _internal_add_sizes();
  public:
  const ::v6::services::pub::SliceSize& sizes(int index) const;
  ::v6::services::pub::SliceSize* add_sizes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceSize >&
      sizes() const;

  // string content_identity = 1;
  void clear_content_identity();
  const std::string& content_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_identity();
  PROTOBUF_NODISCARD std::string* release_content_identity();
  void set_allocated_content_identity(std::string* content_identity);
  private:
  const std::string& _internal_content_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_identity(const std::string& value);
  std::string* _internal_mutable_content_identity();
  public:

  // string sha1 = 6;
  void clear_sha1();
  const std::string& sha1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha1();
  PROTOBUF_NODISCARD std::string* release_sha1();
  void set_allocated_sha1(std::string* sha1);
  private:
  const std::string& _internal_sha1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha1(const std::string& value);
  std::string* _internal_mutable_sha1();
  public:

  // string wcs_etag = 7;
  void clear_wcs_etag();
  const std::string& wcs_etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wcs_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wcs_etag();
  PROTOBUF_NODISCARD std::string* release_wcs_etag();
  void set_allocated_wcs_etag(std::string* wcs_etag);
  private:
  const std::string& _internal_wcs_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wcs_etag(const std::string& value);
  std::string* _internal_mutable_wcs_etag();
  public:

  // int64 file_size = 4;
  void clear_file_size();
  int64_t file_size() const;
  void set_file_size(int64_t value);
  private:
  int64_t _internal_file_size() const;
  void _internal_set_file_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.ParseFileSliceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> meta_nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> raw_nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceSize > sizes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wcs_etag_;
    int64_t file_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SliceSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SliceSize) */ {
 public:
  inline SliceSize() : SliceSize(nullptr) {}
  ~SliceSize() override;
  explicit PROTOBUF_CONSTEXPR SliceSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SliceSize(const SliceSize& from);
  SliceSize(SliceSize&& from) noexcept
    : SliceSize() {
    *this = ::std::move(from);
  }

  inline SliceSize& operator=(const SliceSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline SliceSize& operator=(SliceSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SliceSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const SliceSize* internal_default_instance() {
    return reinterpret_cast<const SliceSize*>(
               &_SliceSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SliceSize& a, SliceSize& b) {
    a.Swap(&b);
  }
  inline void Swap(SliceSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SliceSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SliceSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SliceSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SliceSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SliceSize& from) {
    SliceSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SliceSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SliceSize";
  }
  protected:
  explicit SliceSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartIndexFieldNumber = 1,
    kEndIndexFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // int64 start_index = 1;
  void clear_start_index();
  int64_t start_index() const;
  void set_start_index(int64_t value);
  private:
  int64_t _internal_start_index() const;
  void _internal_set_start_index(int64_t value);
  public:

  // int64 end_index = 2;
  void clear_end_index();
  int64_t end_index() const;
  void set_end_index(int64_t value);
  private:
  int64_t _internal_end_index() const;
  void _internal_set_end_index(int64_t value);
  public:

  // int64 size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SliceSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t start_index_;
    int64_t end_index_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SliceDownloadAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SliceDownloadAddressRequest) */ {
 public:
  inline SliceDownloadAddressRequest() : SliceDownloadAddressRequest(nullptr) {}
  ~SliceDownloadAddressRequest() override;
  explicit PROTOBUF_CONSTEXPR SliceDownloadAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SliceDownloadAddressRequest(const SliceDownloadAddressRequest& from);
  SliceDownloadAddressRequest(SliceDownloadAddressRequest&& from) noexcept
    : SliceDownloadAddressRequest() {
    *this = ::std::move(from);
  }

  inline SliceDownloadAddressRequest& operator=(const SliceDownloadAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SliceDownloadAddressRequest& operator=(SliceDownloadAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SliceDownloadAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SliceDownloadAddressRequest* internal_default_instance() {
    return reinterpret_cast<const SliceDownloadAddressRequest*>(
               &_SliceDownloadAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SliceDownloadAddressRequest& a, SliceDownloadAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SliceDownloadAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SliceDownloadAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SliceDownloadAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SliceDownloadAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SliceDownloadAddressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SliceDownloadAddressRequest& from) {
    SliceDownloadAddressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SliceDownloadAddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SliceDownloadAddressRequest";
  }
  protected:
  explicit SliceDownloadAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
  };
  // repeated string identity = 1;
  int identity_size() const;
  private:
  int _internal_identity_size() const;
  public:
  void clear_identity();
  const std::string& identity(int index) const;
  std::string* mutable_identity(int index);
  void set_identity(int index, const std::string& value);
  void set_identity(int index, std::string&& value);
  void set_identity(int index, const char* value);
  void set_identity(int index, const char* value, size_t size);
  std::string* add_identity();
  void add_identity(const std::string& value);
  void add_identity(std::string&& value);
  void add_identity(const char* value);
  void add_identity(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& identity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_identity();
  private:
  const std::string& _internal_identity(int index) const;
  std::string* _internal_add_identity();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SliceDownloadAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> identity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SliceDownloadAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SliceDownloadAddressResponse) */ {
 public:
  inline SliceDownloadAddressResponse() : SliceDownloadAddressResponse(nullptr) {}
  ~SliceDownloadAddressResponse() override;
  explicit PROTOBUF_CONSTEXPR SliceDownloadAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SliceDownloadAddressResponse(const SliceDownloadAddressResponse& from);
  SliceDownloadAddressResponse(SliceDownloadAddressResponse&& from) noexcept
    : SliceDownloadAddressResponse() {
    *this = ::std::move(from);
  }

  inline SliceDownloadAddressResponse& operator=(const SliceDownloadAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SliceDownloadAddressResponse& operator=(SliceDownloadAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SliceDownloadAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SliceDownloadAddressResponse* internal_default_instance() {
    return reinterpret_cast<const SliceDownloadAddressResponse*>(
               &_SliceDownloadAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SliceDownloadAddressResponse& a, SliceDownloadAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SliceDownloadAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SliceDownloadAddressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SliceDownloadAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SliceDownloadAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SliceDownloadAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SliceDownloadAddressResponse& from) {
    SliceDownloadAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SliceDownloadAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SliceDownloadAddressResponse";
  }
  protected:
  explicit SliceDownloadAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 1,
    kRequestAddressFieldNumber = 3,
    kExpireAtFieldNumber = 2,
  };
  // repeated .v6.services.pub.SliceDownloadInfo addresses = 1;
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  ::v6::services::pub::SliceDownloadInfo* mutable_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceDownloadInfo >*
      mutable_addresses();
  private:
  const ::v6::services::pub::SliceDownloadInfo& _internal_addresses(int index) const;
  ::v6::services::pub::SliceDownloadInfo* _internal_add_addresses();
  public:
  const ::v6::services::pub::SliceDownloadInfo& addresses(int index) const;
  ::v6::services::pub::SliceDownloadInfo* add_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceDownloadInfo >&
      addresses() const;

  // string request_address = 3;
  void clear_request_address();
  const std::string& request_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_address();
  PROTOBUF_NODISCARD std::string* release_request_address();
  void set_allocated_request_address(std::string* request_address);
  private:
  const std::string& _internal_request_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_address(const std::string& value);
  std::string* _internal_mutable_request_address();
  public:

  // int64 expire_at = 2;
  void clear_expire_at();
  int64_t expire_at() const;
  void set_expire_at(int64_t value);
  private:
  int64_t _internal_expire_at() const;
  void _internal_set_expire_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SliceDownloadAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceDownloadInfo > addresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_address_;
    int64_t expire_at_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// -------------------------------------------------------------------

class SliceDownloadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SliceDownloadInfo) */ {
 public:
  inline SliceDownloadInfo() : SliceDownloadInfo(nullptr) {}
  ~SliceDownloadInfo() override;
  explicit PROTOBUF_CONSTEXPR SliceDownloadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SliceDownloadInfo(const SliceDownloadInfo& from);
  SliceDownloadInfo(SliceDownloadInfo&& from) noexcept
    : SliceDownloadInfo() {
    *this = ::std::move(from);
  }

  inline SliceDownloadInfo& operator=(const SliceDownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SliceDownloadInfo& operator=(SliceDownloadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SliceDownloadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SliceDownloadInfo* internal_default_instance() {
    return reinterpret_cast<const SliceDownloadInfo*>(
               &_SliceDownloadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SliceDownloadInfo& a, SliceDownloadInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SliceDownloadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SliceDownloadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SliceDownloadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SliceDownloadInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SliceDownloadInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SliceDownloadInfo& from) {
    SliceDownloadInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SliceDownloadInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SliceDownloadInfo";
  }
  protected:
  explicit SliceDownloadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kDownloadAddressFieldNumber = 2,
    kDownloadTokenFieldNumber = 3,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string download_address = 2;
  void clear_download_address();
  const std::string& download_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_download_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_download_address();
  PROTOBUF_NODISCARD std::string* release_download_address();
  void set_allocated_download_address(std::string* download_address);
  private:
  const std::string& _internal_download_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_download_address(const std::string& value);
  std::string* _internal_mutable_download_address();
  public:

  // string download_token = 3;
  void clear_download_token();
  const std::string& download_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_download_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_download_token();
  PROTOBUF_NODISCARD std::string* release_download_token();
  void set_allocated_download_token(std::string* download_token);
  private:
  const std::string& _internal_download_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_download_token(const std::string& value);
  std::string* _internal_mutable_download_token();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SliceDownloadInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr download_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr download_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_public_5fuser_5ffile_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// File

// string identity = 1;
inline void File::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& File::identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.identity)
}
inline std::string* File::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.identity)
  return _s;
}
inline const std::string& File::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void File::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.identity)
  return _impl_.identity_.Release();
}
inline void File::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.identity)
}

// string parent = 3;
inline void File::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& File::parent() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.parent)
}
inline std::string* File::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.parent)
  return _s;
}
inline const std::string& File::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void File::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_parent() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.parent)
  return _impl_.parent_.Release();
}
inline void File::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.parent)
}

// string name = 4;
inline void File::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& File::name() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.name)
}
inline std::string* File::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.name)
  return _s;
}
inline const std::string& File::_internal_name() const {
  return _impl_.name_.Get();
}
inline void File::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_name() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.name)
  return _impl_.name_.Release();
}
inline void File::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.name)
}

// string path = 5;
inline void File::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& File::path() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.path)
}
inline std::string* File::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.path)
  return _s;
}
inline const std::string& File::_internal_path() const {
  return _impl_.path_.Get();
}
inline void File::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_path() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.path)
  return _impl_.path_.Release();
}
inline void File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.path)
}

// string mime_type = 6;
inline void File::clear_mime_type() {
  _impl_.mime_type_.ClearToEmpty();
}
inline const std::string& File::mime_type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_mime_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.mime_type)
}
inline std::string* File::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.mime_type)
  return _s;
}
inline const std::string& File::_internal_mime_type() const {
  return _impl_.mime_type_.Get();
}
inline void File::_internal_set_mime_type(const std::string& value) {
  
  _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_mime_type() {
  
  return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_mime_type() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.mime_type)
  return _impl_.mime_type_.Release();
}
inline void File::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    
  } else {
    
  }
  _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mime_type_.IsDefault()) {
    _impl_.mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.mime_type)
}

// int64 size = 7;
inline void File::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t File::_internal_size() const {
  return _impl_.size_;
}
inline int64_t File::size() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.size)
  return _internal_size();
}
inline void File::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void File::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.size)
}

// int64 type = 8;
inline void File::clear_type() {
  _impl_.type_ = int64_t{0};
}
inline int64_t File::_internal_type() const {
  return _impl_.type_;
}
inline int64_t File::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.type)
  return _internal_type();
}
inline void File::_internal_set_type(int64_t value) {
  
  _impl_.type_ = value;
}
inline void File::set_type(int64_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.type)
}

// int64 created_at = 9;
inline void File::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t File::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t File::created_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.created_at)
  return _internal_created_at();
}
inline void File::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void File::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.created_at)
}

// int64 updated_at = 10;
inline void File::clear_updated_at() {
  _impl_.updated_at_ = int64_t{0};
}
inline int64_t File::_internal_updated_at() const {
  return _impl_.updated_at_;
}
inline int64_t File::updated_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.updated_at)
  return _internal_updated_at();
}
inline void File::_internal_set_updated_at(int64_t value) {
  
  _impl_.updated_at_ = value;
}
inline void File::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.updated_at)
}

// int64 deleted_at = 11;
inline void File::clear_deleted_at() {
  _impl_.deleted_at_ = int64_t{0};
}
inline int64_t File::_internal_deleted_at() const {
  return _impl_.deleted_at_;
}
inline int64_t File::deleted_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.deleted_at)
  return _internal_deleted_at();
}
inline void File::_internal_set_deleted_at(int64_t value) {
  
  _impl_.deleted_at_ = value;
}
inline void File::set_deleted_at(int64_t value) {
  _internal_set_deleted_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.deleted_at)
}

// bool deleted = 12;
inline void File::clear_deleted() {
  _impl_.deleted_ = false;
}
inline bool File::_internal_deleted() const {
  return _impl_.deleted_;
}
inline bool File::deleted() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.deleted)
  return _internal_deleted();
}
inline void File::_internal_set_deleted(bool value) {
  
  _impl_.deleted_ = value;
}
inline void File::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.deleted)
}

// bool dir = 13;
inline void File::clear_dir() {
  _impl_.dir_ = false;
}
inline bool File::_internal_dir() const {
  return _impl_.dir_;
}
inline bool File::dir() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.dir)
  return _internal_dir();
}
inline void File::_internal_set_dir(bool value) {
  
  _impl_.dir_ = value;
}
inline void File::set_dir(bool value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.dir)
}

// bool hidden = 14;
inline void File::clear_hidden() {
  _impl_.hidden_ = false;
}
inline bool File::_internal_hidden() const {
  return _impl_.hidden_;
}
inline bool File::hidden() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.hidden)
  return _internal_hidden();
}
inline void File::_internal_set_hidden(bool value) {
  
  _impl_.hidden_ = value;
}
inline void File::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.hidden)
}

// bool locked = 15;
inline void File::clear_locked() {
  _impl_.locked_ = false;
}
inline bool File::_internal_locked() const {
  return _impl_.locked_;
}
inline bool File::locked() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.locked)
  return _internal_locked();
}
inline void File::_internal_set_locked(bool value) {
  
  _impl_.locked_ = value;
}
inline void File::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.locked)
}

// bool shared = 16;
inline void File::clear_shared() {
  _impl_.shared_ = false;
}
inline bool File::_internal_shared() const {
  return _impl_.shared_;
}
inline bool File::shared() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.shared)
  return _internal_shared();
}
inline void File::_internal_set_shared(bool value) {
  
  _impl_.shared_ = value;
}
inline void File::set_shared(bool value) {
  _internal_set_shared(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.shared)
}

// bool starred = 17;
inline void File::clear_starred() {
  _impl_.starred_ = false;
}
inline bool File::_internal_starred() const {
  return _impl_.starred_;
}
inline bool File::starred() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.starred)
  return _internal_starred();
}
inline void File::_internal_set_starred(bool value) {
  
  _impl_.starred_ = value;
}
inline void File::set_starred(bool value) {
  _internal_set_starred(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.starred)
}

// bool trashed = 18;
inline void File::clear_trashed() {
  _impl_.trashed_ = false;
}
inline bool File::_internal_trashed() const {
  return _impl_.trashed_;
}
inline bool File::trashed() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.trashed)
  return _internal_trashed();
}
inline void File::_internal_set_trashed(bool value) {
  
  _impl_.trashed_ = value;
}
inline void File::set_trashed(bool value) {
  _internal_set_trashed(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.trashed)
}

// int64 locked_at = 19;
inline void File::clear_locked_at() {
  _impl_.locked_at_ = int64_t{0};
}
inline int64_t File::_internal_locked_at() const {
  return _impl_.locked_at_;
}
inline int64_t File::locked_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.locked_at)
  return _internal_locked_at();
}
inline void File::_internal_set_locked_at(int64_t value) {
  
  _impl_.locked_at_ = value;
}
inline void File::set_locked_at(int64_t value) {
  _internal_set_locked_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.locked_at)
}

// string locked_by = 20;
inline void File::clear_locked_by() {
  _impl_.locked_by_.ClearToEmpty();
}
inline const std::string& File::locked_by() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.locked_by)
  return _internal_locked_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_locked_by(ArgT0&& arg0, ArgT... args) {
 
 _impl_.locked_by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.locked_by)
}
inline std::string* File::mutable_locked_by() {
  std::string* _s = _internal_mutable_locked_by();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.locked_by)
  return _s;
}
inline const std::string& File::_internal_locked_by() const {
  return _impl_.locked_by_.Get();
}
inline void File::_internal_set_locked_by(const std::string& value) {
  
  _impl_.locked_by_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_locked_by() {
  
  return _impl_.locked_by_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_locked_by() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.locked_by)
  return _impl_.locked_by_.Release();
}
inline void File::set_allocated_locked_by(std::string* locked_by) {
  if (locked_by != nullptr) {
    
  } else {
    
  }
  _impl_.locked_by_.SetAllocated(locked_by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.locked_by_.IsDefault()) {
    _impl_.locked_by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.locked_by)
}

// int64 shared_at = 21;
inline void File::clear_shared_at() {
  _impl_.shared_at_ = int64_t{0};
}
inline int64_t File::_internal_shared_at() const {
  return _impl_.shared_at_;
}
inline int64_t File::shared_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.shared_at)
  return _internal_shared_at();
}
inline void File::_internal_set_shared_at(int64_t value) {
  
  _impl_.shared_at_ = value;
}
inline void File::set_shared_at(int64_t value) {
  _internal_set_shared_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.shared_at)
}

// int64 flag = 22;
inline void File::clear_flag() {
  _impl_.flag_ = int64_t{0};
}
inline int64_t File::_internal_flag() const {
  return _impl_.flag_;
}
inline int64_t File::flag() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.flag)
  return _internal_flag();
}
inline void File::_internal_set_flag(int64_t value) {
  
  _impl_.flag_ = value;
}
inline void File::set_flag(int64_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.flag)
}

// string unique = 23;
inline void File::clear_unique() {
  _impl_.unique_.ClearToEmpty();
}
inline const std::string& File::unique() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.unique)
  return _internal_unique();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_unique(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unique_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.unique)
}
inline std::string* File::mutable_unique() {
  std::string* _s = _internal_mutable_unique();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.unique)
  return _s;
}
inline const std::string& File::_internal_unique() const {
  return _impl_.unique_.Get();
}
inline void File::_internal_set_unique(const std::string& value) {
  
  _impl_.unique_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_unique() {
  
  return _impl_.unique_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_unique() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.unique)
  return _impl_.unique_.Release();
}
inline void File::set_allocated_unique(std::string* unique) {
  if (unique != nullptr) {
    
  } else {
    
  }
  _impl_.unique_.SetAllocated(unique, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unique_.IsDefault()) {
    _impl_.unique_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.unique)
}

// string content_identity = 24;
inline void File::clear_content_identity() {
  _impl_.content_identity_.ClearToEmpty();
}
inline const std::string& File::content_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.content_identity)
  return _internal_content_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_content_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.File.content_identity)
}
inline std::string* File::mutable_content_identity() {
  std::string* _s = _internal_mutable_content_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.File.content_identity)
  return _s;
}
inline const std::string& File::_internal_content_identity() const {
  return _impl_.content_identity_.Get();
}
inline void File::_internal_set_content_identity(const std::string& value) {
  
  _impl_.content_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_content_identity() {
  
  return _impl_.content_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_content_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.File.content_identity)
  return _impl_.content_identity_.Release();
}
inline void File::set_allocated_content_identity(std::string* content_identity) {
  if (content_identity != nullptr) {
    
  } else {
    
  }
  _impl_.content_identity_.SetAllocated(content_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_identity_.IsDefault()) {
    _impl_.content_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.File.content_identity)
}

// int64 label = 25;
inline void File::clear_label() {
  _impl_.label_ = int64_t{0};
}
inline int64_t File::_internal_label() const {
  return _impl_.label_;
}
inline int64_t File::label() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.File.label)
  return _internal_label();
}
inline void File::_internal_set_label(int64_t value) {
  
  _impl_.label_ = value;
}
inline void File::set_label(int64_t value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.File.label)
}

// -------------------------------------------------------------------

// FileListRequest

// .v6.services.pub.File parent = 1;
inline bool FileListRequest::_internal_has_parent() const {
  return this != internal_default_instance() && _impl_.parent_ != nullptr;
}
inline bool FileListRequest::has_parent() const {
  return _internal_has_parent();
}
inline void FileListRequest::clear_parent() {
  if (GetArenaForAllocation() == nullptr && _impl_.parent_ != nullptr) {
    delete _impl_.parent_;
  }
  _impl_.parent_ = nullptr;
}
inline const ::v6::services::pub::File& FileListRequest::_internal_parent() const {
  const ::v6::services::pub::File* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::File&>(
      ::v6::services::pub::_File_default_instance_);
}
inline const ::v6::services::pub::File& FileListRequest::parent() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.FileListRequest.parent)
  return _internal_parent();
}
inline void FileListRequest::unsafe_arena_set_allocated_parent(
    ::v6::services::pub::File* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.FileListRequest.parent)
}
inline ::v6::services::pub::File* FileListRequest::release_parent() {
  
  ::v6::services::pub::File* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::File* FileListRequest::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:v6.services.pub.FileListRequest.parent)
  
  ::v6::services::pub::File* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::v6::services::pub::File* FileListRequest::_internal_mutable_parent() {
  
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::File>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::v6::services::pub::File* FileListRequest::mutable_parent() {
  ::v6::services::pub::File* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.FileListRequest.parent)
  return _msg;
}
inline void FileListRequest::set_allocated_parent(::v6::services::pub::File* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.FileListRequest.parent)
}

// .v6.services.pub.File filter = 2;
inline bool FileListRequest::_internal_has_filter() const {
  return this != internal_default_instance() && _impl_.filter_ != nullptr;
}
inline bool FileListRequest::has_filter() const {
  return _internal_has_filter();
}
inline void FileListRequest::clear_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.filter_ != nullptr) {
    delete _impl_.filter_;
  }
  _impl_.filter_ = nullptr;
}
inline const ::v6::services::pub::File& FileListRequest::_internal_filter() const {
  const ::v6::services::pub::File* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::File&>(
      ::v6::services::pub::_File_default_instance_);
}
inline const ::v6::services::pub::File& FileListRequest::filter() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.FileListRequest.filter)
  return _internal_filter();
}
inline void FileListRequest::unsafe_arena_set_allocated_filter(
    ::v6::services::pub::File* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.FileListRequest.filter)
}
inline ::v6::services::pub::File* FileListRequest::release_filter() {
  
  ::v6::services::pub::File* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::File* FileListRequest::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:v6.services.pub.FileListRequest.filter)
  
  ::v6::services::pub::File* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::v6::services::pub::File* FileListRequest::_internal_mutable_filter() {
  
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::File>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::v6::services::pub::File* FileListRequest::mutable_filter() {
  ::v6::services::pub::File* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.FileListRequest.filter)
  return _msg;
}
inline void FileListRequest::set_allocated_filter(::v6::services::pub::File* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.FileListRequest.filter)
}

// .v6.services.pub.common.ScanListRequest list_info = 3;
inline bool FileListRequest::_internal_has_list_info() const {
  return this != internal_default_instance() && _impl_.list_info_ != nullptr;
}
inline bool FileListRequest::has_list_info() const {
  return _internal_has_list_info();
}
inline const ::v6::services::pub::common::ScanListRequest& FileListRequest::_internal_list_info() const {
  const ::v6::services::pub::common::ScanListRequest* p = _impl_.list_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::common::ScanListRequest&>(
      ::v6::services::pub::common::_ScanListRequest_default_instance_);
}
inline const ::v6::services::pub::common::ScanListRequest& FileListRequest::list_info() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.FileListRequest.list_info)
  return _internal_list_info();
}
inline void FileListRequest::unsafe_arena_set_allocated_list_info(
    ::v6::services::pub::common::ScanListRequest* list_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_info_);
  }
  _impl_.list_info_ = list_info;
  if (list_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.FileListRequest.list_info)
}
inline ::v6::services::pub::common::ScanListRequest* FileListRequest::release_list_info() {
  
  ::v6::services::pub::common::ScanListRequest* temp = _impl_.list_info_;
  _impl_.list_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::common::ScanListRequest* FileListRequest::unsafe_arena_release_list_info() {
  // @@protoc_insertion_point(field_release:v6.services.pub.FileListRequest.list_info)
  
  ::v6::services::pub::common::ScanListRequest* temp = _impl_.list_info_;
  _impl_.list_info_ = nullptr;
  return temp;
}
inline ::v6::services::pub::common::ScanListRequest* FileListRequest::_internal_mutable_list_info() {
  
  if (_impl_.list_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::common::ScanListRequest>(GetArenaForAllocation());
    _impl_.list_info_ = p;
  }
  return _impl_.list_info_;
}
inline ::v6::services::pub::common::ScanListRequest* FileListRequest::mutable_list_info() {
  ::v6::services::pub::common::ScanListRequest* _msg = _internal_mutable_list_info();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.FileListRequest.list_info)
  return _msg;
}
inline void FileListRequest::set_allocated_list_info(::v6::services::pub::common::ScanListRequest* list_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_info_);
  }
  if (list_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(list_info));
    if (message_arena != submessage_arena) {
      list_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_info_ = list_info;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.FileListRequest.list_info)
}

// -------------------------------------------------------------------

// SearchRequest

// string name = 1;
inline void SearchRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SearchRequest::name() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SearchRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SearchRequest.name)
}
inline std::string* SearchRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SearchRequest.name)
  return _s;
}
inline const std::string& SearchRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SearchRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchRequest::release_name() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SearchRequest.name)
  return _impl_.name_.Release();
}
inline void SearchRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SearchRequest.name)
}

// .v6.services.pub.common.ScanListRequest list_info = 3;
inline bool SearchRequest::_internal_has_list_info() const {
  return this != internal_default_instance() && _impl_.list_info_ != nullptr;
}
inline bool SearchRequest::has_list_info() const {
  return _internal_has_list_info();
}
inline const ::v6::services::pub::common::ScanListRequest& SearchRequest::_internal_list_info() const {
  const ::v6::services::pub::common::ScanListRequest* p = _impl_.list_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::common::ScanListRequest&>(
      ::v6::services::pub::common::_ScanListRequest_default_instance_);
}
inline const ::v6::services::pub::common::ScanListRequest& SearchRequest::list_info() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SearchRequest.list_info)
  return _internal_list_info();
}
inline void SearchRequest::unsafe_arena_set_allocated_list_info(
    ::v6::services::pub::common::ScanListRequest* list_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_info_);
  }
  _impl_.list_info_ = list_info;
  if (list_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.SearchRequest.list_info)
}
inline ::v6::services::pub::common::ScanListRequest* SearchRequest::release_list_info() {
  
  ::v6::services::pub::common::ScanListRequest* temp = _impl_.list_info_;
  _impl_.list_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::common::ScanListRequest* SearchRequest::unsafe_arena_release_list_info() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SearchRequest.list_info)
  
  ::v6::services::pub::common::ScanListRequest* temp = _impl_.list_info_;
  _impl_.list_info_ = nullptr;
  return temp;
}
inline ::v6::services::pub::common::ScanListRequest* SearchRequest::_internal_mutable_list_info() {
  
  if (_impl_.list_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::common::ScanListRequest>(GetArenaForAllocation());
    _impl_.list_info_ = p;
  }
  return _impl_.list_info_;
}
inline ::v6::services::pub::common::ScanListRequest* SearchRequest::mutable_list_info() {
  ::v6::services::pub::common::ScanListRequest* _msg = _internal_mutable_list_info();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SearchRequest.list_info)
  return _msg;
}
inline void SearchRequest::set_allocated_list_info(::v6::services::pub::common::ScanListRequest* list_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_info_);
  }
  if (list_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(list_info));
    if (message_arena != submessage_arena) {
      list_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_info_ = list_info;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SearchRequest.list_info)
}

// -------------------------------------------------------------------

// FileListResponse

// repeated .v6.services.pub.File files = 1;
inline int FileListResponse::_internal_files_size() const {
  return _impl_.files_.size();
}
inline int FileListResponse::files_size() const {
  return _internal_files_size();
}
inline void FileListResponse::clear_files() {
  _impl_.files_.Clear();
}
inline ::v6::services::pub::File* FileListResponse::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.FileListResponse.files)
  return _impl_.files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >*
FileListResponse::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.FileListResponse.files)
  return &_impl_.files_;
}
inline const ::v6::services::pub::File& FileListResponse::_internal_files(int index) const {
  return _impl_.files_.Get(index);
}
inline const ::v6::services::pub::File& FileListResponse::files(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.FileListResponse.files)
  return _internal_files(index);
}
inline ::v6::services::pub::File* FileListResponse::_internal_add_files() {
  return _impl_.files_.Add();
}
inline ::v6::services::pub::File* FileListResponse::add_files() {
  ::v6::services::pub::File* _add = _internal_add_files();
  // @@protoc_insertion_point(field_add:v6.services.pub.FileListResponse.files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >&
FileListResponse::files() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.FileListResponse.files)
  return _impl_.files_;
}

// .v6.services.pub.common.ScanListRequest list_info = 2;
inline bool FileListResponse::_internal_has_list_info() const {
  return this != internal_default_instance() && _impl_.list_info_ != nullptr;
}
inline bool FileListResponse::has_list_info() const {
  return _internal_has_list_info();
}
inline const ::v6::services::pub::common::ScanListRequest& FileListResponse::_internal_list_info() const {
  const ::v6::services::pub::common::ScanListRequest* p = _impl_.list_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::common::ScanListRequest&>(
      ::v6::services::pub::common::_ScanListRequest_default_instance_);
}
inline const ::v6::services::pub::common::ScanListRequest& FileListResponse::list_info() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.FileListResponse.list_info)
  return _internal_list_info();
}
inline void FileListResponse::unsafe_arena_set_allocated_list_info(
    ::v6::services::pub::common::ScanListRequest* list_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_info_);
  }
  _impl_.list_info_ = list_info;
  if (list_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.FileListResponse.list_info)
}
inline ::v6::services::pub::common::ScanListRequest* FileListResponse::release_list_info() {
  
  ::v6::services::pub::common::ScanListRequest* temp = _impl_.list_info_;
  _impl_.list_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::common::ScanListRequest* FileListResponse::unsafe_arena_release_list_info() {
  // @@protoc_insertion_point(field_release:v6.services.pub.FileListResponse.list_info)
  
  ::v6::services::pub::common::ScanListRequest* temp = _impl_.list_info_;
  _impl_.list_info_ = nullptr;
  return temp;
}
inline ::v6::services::pub::common::ScanListRequest* FileListResponse::_internal_mutable_list_info() {
  
  if (_impl_.list_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::common::ScanListRequest>(GetArenaForAllocation());
    _impl_.list_info_ = p;
  }
  return _impl_.list_info_;
}
inline ::v6::services::pub::common::ScanListRequest* FileListResponse::mutable_list_info() {
  ::v6::services::pub::common::ScanListRequest* _msg = _internal_mutable_list_info();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.FileListResponse.list_info)
  return _msg;
}
inline void FileListResponse::set_allocated_list_info(::v6::services::pub::common::ScanListRequest* list_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_info_);
  }
  if (list_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(list_info));
    if (message_arena != submessage_arena) {
      list_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_info_ = list_info;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.FileListResponse.list_info)
}

// -------------------------------------------------------------------

// BatchOperationRequest

// repeated .v6.services.pub.File source = 1;
inline int BatchOperationRequest::_internal_source_size() const {
  return _impl_.source_.size();
}
inline int BatchOperationRequest::source_size() const {
  return _internal_source_size();
}
inline void BatchOperationRequest::clear_source() {
  _impl_.source_.Clear();
}
inline ::v6::services::pub::File* BatchOperationRequest::mutable_source(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.BatchOperationRequest.source)
  return _impl_.source_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >*
BatchOperationRequest::mutable_source() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.BatchOperationRequest.source)
  return &_impl_.source_;
}
inline const ::v6::services::pub::File& BatchOperationRequest::_internal_source(int index) const {
  return _impl_.source_.Get(index);
}
inline const ::v6::services::pub::File& BatchOperationRequest::source(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationRequest.source)
  return _internal_source(index);
}
inline ::v6::services::pub::File* BatchOperationRequest::_internal_add_source() {
  return _impl_.source_.Add();
}
inline ::v6::services::pub::File* BatchOperationRequest::add_source() {
  ::v6::services::pub::File* _add = _internal_add_source();
  // @@protoc_insertion_point(field_add:v6.services.pub.BatchOperationRequest.source)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::File >&
BatchOperationRequest::source() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.BatchOperationRequest.source)
  return _impl_.source_;
}

// .v6.services.pub.File dest = 2;
inline bool BatchOperationRequest::_internal_has_dest() const {
  return this != internal_default_instance() && _impl_.dest_ != nullptr;
}
inline bool BatchOperationRequest::has_dest() const {
  return _internal_has_dest();
}
inline void BatchOperationRequest::clear_dest() {
  if (GetArenaForAllocation() == nullptr && _impl_.dest_ != nullptr) {
    delete _impl_.dest_;
  }
  _impl_.dest_ = nullptr;
}
inline const ::v6::services::pub::File& BatchOperationRequest::_internal_dest() const {
  const ::v6::services::pub::File* p = _impl_.dest_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::File&>(
      ::v6::services::pub::_File_default_instance_);
}
inline const ::v6::services::pub::File& BatchOperationRequest::dest() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationRequest.dest)
  return _internal_dest();
}
inline void BatchOperationRequest::unsafe_arena_set_allocated_dest(
    ::v6::services::pub::File* dest) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dest_);
  }
  _impl_.dest_ = dest;
  if (dest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.BatchOperationRequest.dest)
}
inline ::v6::services::pub::File* BatchOperationRequest::release_dest() {
  
  ::v6::services::pub::File* temp = _impl_.dest_;
  _impl_.dest_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::File* BatchOperationRequest::unsafe_arena_release_dest() {
  // @@protoc_insertion_point(field_release:v6.services.pub.BatchOperationRequest.dest)
  
  ::v6::services::pub::File* temp = _impl_.dest_;
  _impl_.dest_ = nullptr;
  return temp;
}
inline ::v6::services::pub::File* BatchOperationRequest::_internal_mutable_dest() {
  
  if (_impl_.dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::File>(GetArenaForAllocation());
    _impl_.dest_ = p;
  }
  return _impl_.dest_;
}
inline ::v6::services::pub::File* BatchOperationRequest::mutable_dest() {
  ::v6::services::pub::File* _msg = _internal_mutable_dest();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.BatchOperationRequest.dest)
  return _msg;
}
inline void BatchOperationRequest::set_allocated_dest(::v6::services::pub::File* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dest_;
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dest);
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.BatchOperationRequest.dest)
}

// int32 operation = 3;
inline void BatchOperationRequest::clear_operation() {
  _impl_.operation_ = 0;
}
inline int32_t BatchOperationRequest::_internal_operation() const {
  return _impl_.operation_;
}
inline int32_t BatchOperationRequest::operation() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationRequest.operation)
  return _internal_operation();
}
inline void BatchOperationRequest::_internal_set_operation(int32_t value) {
  
  _impl_.operation_ = value;
}
inline void BatchOperationRequest::set_operation(int32_t value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationRequest.operation)
}

// int32 flag = 4;
inline void BatchOperationRequest::clear_flag() {
  _impl_.flag_ = 0;
}
inline int32_t BatchOperationRequest::_internal_flag() const {
  return _impl_.flag_;
}
inline int32_t BatchOperationRequest::flag() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationRequest.flag)
  return _internal_flag();
}
inline void BatchOperationRequest::_internal_set_flag(int32_t value) {
  
  _impl_.flag_ = value;
}
inline void BatchOperationRequest::set_flag(int32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationRequest.flag)
}

// -------------------------------------------------------------------

// BatchOperationResponse

// string task = 1;
inline void BatchOperationResponse::clear_task() {
  _impl_.task_.ClearToEmpty();
}
inline const std::string& BatchOperationResponse::task() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationResponse.task)
  return _internal_task();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchOperationResponse::set_task(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationResponse.task)
}
inline std::string* BatchOperationResponse::mutable_task() {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.BatchOperationResponse.task)
  return _s;
}
inline const std::string& BatchOperationResponse::_internal_task() const {
  return _impl_.task_.Get();
}
inline void BatchOperationResponse::_internal_set_task(const std::string& value) {
  
  _impl_.task_.Set(value, GetArenaForAllocation());
}
inline std::string* BatchOperationResponse::_internal_mutable_task() {
  
  return _impl_.task_.Mutable(GetArenaForAllocation());
}
inline std::string* BatchOperationResponse::release_task() {
  // @@protoc_insertion_point(field_release:v6.services.pub.BatchOperationResponse.task)
  return _impl_.task_.Release();
}
inline void BatchOperationResponse::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    
  } else {
    
  }
  _impl_.task_.SetAllocated(task, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.BatchOperationResponse.task)
}

// int32 status = 2;
inline void BatchOperationResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t BatchOperationResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t BatchOperationResponse::status() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationResponse.status)
  return _internal_status();
}
inline void BatchOperationResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void BatchOperationResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationResponse.status)
}

// int64 affected = 3;
inline void BatchOperationResponse::clear_affected() {
  _impl_.affected_ = int64_t{0};
}
inline int64_t BatchOperationResponse::_internal_affected() const {
  return _impl_.affected_;
}
inline int64_t BatchOperationResponse::affected() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationResponse.affected)
  return _internal_affected();
}
inline void BatchOperationResponse::_internal_set_affected(int64_t value) {
  
  _impl_.affected_ = value;
}
inline void BatchOperationResponse::set_affected(int64_t value) {
  _internal_set_affected(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationResponse.affected)
}

// int64 created_at = 4;
inline void BatchOperationResponse::clear_created_at() {
  _impl_.created_at_ = int64_t{0};
}
inline int64_t BatchOperationResponse::_internal_created_at() const {
  return _impl_.created_at_;
}
inline int64_t BatchOperationResponse::created_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationResponse.created_at)
  return _internal_created_at();
}
inline void BatchOperationResponse::_internal_set_created_at(int64_t value) {
  
  _impl_.created_at_ = value;
}
inline void BatchOperationResponse::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationResponse.created_at)
}

// int64 progress = 5;
inline void BatchOperationResponse::clear_progress() {
  _impl_.progress_ = int64_t{0};
}
inline int64_t BatchOperationResponse::_internal_progress() const {
  return _impl_.progress_;
}
inline int64_t BatchOperationResponse::progress() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.BatchOperationResponse.progress)
  return _internal_progress();
}
inline void BatchOperationResponse::_internal_set_progress(int64_t value) {
  
  _impl_.progress_ = value;
}
inline void BatchOperationResponse::set_progress(int64_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.BatchOperationResponse.progress)
}

// -------------------------------------------------------------------

// ManageRTCRequest

// string sdp = 1;
inline void ManageRTCRequest::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& ManageRTCRequest::sdp() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCRequest.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCRequest::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCRequest.sdp)
}
inline std::string* ManageRTCRequest::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCRequest.sdp)
  return _s;
}
inline const std::string& ManageRTCRequest::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void ManageRTCRequest::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCRequest::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCRequest::release_sdp() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCRequest.sdp)
  return _impl_.sdp_.Release();
}
inline void ManageRTCRequest::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCRequest.sdp)
}

// string offer = 2;
inline void ManageRTCRequest::clear_offer() {
  _impl_.offer_.ClearToEmpty();
}
inline const std::string& ManageRTCRequest::offer() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCRequest.offer)
  return _internal_offer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCRequest::set_offer(ArgT0&& arg0, ArgT... args) {
 
 _impl_.offer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCRequest.offer)
}
inline std::string* ManageRTCRequest::mutable_offer() {
  std::string* _s = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCRequest.offer)
  return _s;
}
inline const std::string& ManageRTCRequest::_internal_offer() const {
  return _impl_.offer_.Get();
}
inline void ManageRTCRequest::_internal_set_offer(const std::string& value) {
  
  _impl_.offer_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCRequest::_internal_mutable_offer() {
  
  return _impl_.offer_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCRequest::release_offer() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCRequest.offer)
  return _impl_.offer_.Release();
}
inline void ManageRTCRequest::set_allocated_offer(std::string* offer) {
  if (offer != nullptr) {
    
  } else {
    
  }
  _impl_.offer_.SetAllocated(offer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offer_.IsDefault()) {
    _impl_.offer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCRequest.offer)
}

// string client_identity = 3;
inline void ManageRTCRequest::clear_client_identity() {
  _impl_.client_identity_.ClearToEmpty();
}
inline const std::string& ManageRTCRequest::client_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCRequest.client_identity)
  return _internal_client_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCRequest::set_client_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCRequest.client_identity)
}
inline std::string* ManageRTCRequest::mutable_client_identity() {
  std::string* _s = _internal_mutable_client_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCRequest.client_identity)
  return _s;
}
inline const std::string& ManageRTCRequest::_internal_client_identity() const {
  return _impl_.client_identity_.Get();
}
inline void ManageRTCRequest::_internal_set_client_identity(const std::string& value) {
  
  _impl_.client_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCRequest::_internal_mutable_client_identity() {
  
  return _impl_.client_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCRequest::release_client_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCRequest.client_identity)
  return _impl_.client_identity_.Release();
}
inline void ManageRTCRequest::set_allocated_client_identity(std::string* client_identity) {
  if (client_identity != nullptr) {
    
  } else {
    
  }
  _impl_.client_identity_.SetAllocated(client_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_identity_.IsDefault()) {
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCRequest.client_identity)
}

// -------------------------------------------------------------------

// ManageRTCResponse

// int64 file_size = 1;
inline void ManageRTCResponse::clear_file_size() {
  _impl_.file_size_ = int64_t{0};
}
inline int64_t ManageRTCResponse::_internal_file_size() const {
  return _impl_.file_size_;
}
inline int64_t ManageRTCResponse::file_size() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCResponse.file_size)
  return _internal_file_size();
}
inline void ManageRTCResponse::_internal_set_file_size(int64_t value) {
  
  _impl_.file_size_ = value;
}
inline void ManageRTCResponse::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCResponse.file_size)
}

// string encode_key = 2;
inline void ManageRTCResponse::clear_encode_key() {
  _impl_.encode_key_.ClearToEmpty();
}
inline const std::string& ManageRTCResponse::encode_key() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCResponse.encode_key)
  return _internal_encode_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCResponse::set_encode_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.encode_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCResponse.encode_key)
}
inline std::string* ManageRTCResponse::mutable_encode_key() {
  std::string* _s = _internal_mutable_encode_key();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCResponse.encode_key)
  return _s;
}
inline const std::string& ManageRTCResponse::_internal_encode_key() const {
  return _impl_.encode_key_.Get();
}
inline void ManageRTCResponse::_internal_set_encode_key(const std::string& value) {
  
  _impl_.encode_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::_internal_mutable_encode_key() {
  
  return _impl_.encode_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::release_encode_key() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCResponse.encode_key)
  return _impl_.encode_key_.Release();
}
inline void ManageRTCResponse::set_allocated_encode_key(std::string* encode_key) {
  if (encode_key != nullptr) {
    
  } else {
    
  }
  _impl_.encode_key_.SetAllocated(encode_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.encode_key_.IsDefault()) {
    _impl_.encode_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCResponse.encode_key)
}

// string sdp = 3;
inline void ManageRTCResponse::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& ManageRTCResponse::sdp() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCResponse.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCResponse::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCResponse.sdp)
}
inline std::string* ManageRTCResponse::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCResponse.sdp)
  return _s;
}
inline const std::string& ManageRTCResponse::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void ManageRTCResponse::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::release_sdp() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCResponse.sdp)
  return _impl_.sdp_.Release();
}
inline void ManageRTCResponse::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCResponse.sdp)
}

// string name = 4;
inline void ManageRTCResponse::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ManageRTCResponse::name() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCResponse.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCResponse::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCResponse.name)
}
inline std::string* ManageRTCResponse::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCResponse.name)
  return _s;
}
inline const std::string& ManageRTCResponse::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ManageRTCResponse::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::release_name() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCResponse.name)
  return _impl_.name_.Release();
}
inline void ManageRTCResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCResponse.name)
}

// string connection = 5;
inline void ManageRTCResponse::clear_connection() {
  _impl_.connection_.ClearToEmpty();
}
inline const std::string& ManageRTCResponse::connection() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ManageRTCResponse.connection)
  return _internal_connection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ManageRTCResponse::set_connection(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connection_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ManageRTCResponse.connection)
}
inline std::string* ManageRTCResponse::mutable_connection() {
  std::string* _s = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ManageRTCResponse.connection)
  return _s;
}
inline const std::string& ManageRTCResponse::_internal_connection() const {
  return _impl_.connection_.Get();
}
inline void ManageRTCResponse::_internal_set_connection(const std::string& value) {
  
  _impl_.connection_.Set(value, GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::_internal_mutable_connection() {
  
  return _impl_.connection_.Mutable(GetArenaForAllocation());
}
inline std::string* ManageRTCResponse::release_connection() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ManageRTCResponse.connection)
  return _impl_.connection_.Release();
}
inline void ManageRTCResponse::set_allocated_connection(std::string* connection) {
  if (connection != nullptr) {
    
  } else {
    
  }
  _impl_.connection_.SetAllocated(connection, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connection_.IsDefault()) {
    _impl_.connection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ManageRTCResponse.connection)
}

// -------------------------------------------------------------------

// SendIceCandidateRequest

// string client_identity = 1;
inline void SendIceCandidateRequest::clear_client_identity() {
  _impl_.client_identity_.ClearToEmpty();
}
inline const std::string& SendIceCandidateRequest::client_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SendIceCandidateRequest.client_identity)
  return _internal_client_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendIceCandidateRequest::set_client_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SendIceCandidateRequest.client_identity)
}
inline std::string* SendIceCandidateRequest::mutable_client_identity() {
  std::string* _s = _internal_mutable_client_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SendIceCandidateRequest.client_identity)
  return _s;
}
inline const std::string& SendIceCandidateRequest::_internal_client_identity() const {
  return _impl_.client_identity_.Get();
}
inline void SendIceCandidateRequest::_internal_set_client_identity(const std::string& value) {
  
  _impl_.client_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SendIceCandidateRequest::_internal_mutable_client_identity() {
  
  return _impl_.client_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SendIceCandidateRequest::release_client_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SendIceCandidateRequest.client_identity)
  return _impl_.client_identity_.Release();
}
inline void SendIceCandidateRequest::set_allocated_client_identity(std::string* client_identity) {
  if (client_identity != nullptr) {
    
  } else {
    
  }
  _impl_.client_identity_.SetAllocated(client_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_identity_.IsDefault()) {
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SendIceCandidateRequest.client_identity)
}

// string candidate = 2;
inline void SendIceCandidateRequest::clear_candidate() {
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& SendIceCandidateRequest::candidate() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SendIceCandidateRequest.candidate)
  return _internal_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendIceCandidateRequest::set_candidate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.candidate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SendIceCandidateRequest.candidate)
}
inline std::string* SendIceCandidateRequest::mutable_candidate() {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SendIceCandidateRequest.candidate)
  return _s;
}
inline const std::string& SendIceCandidateRequest::_internal_candidate() const {
  return _impl_.candidate_.Get();
}
inline void SendIceCandidateRequest::_internal_set_candidate(const std::string& value) {
  
  _impl_.candidate_.Set(value, GetArenaForAllocation());
}
inline std::string* SendIceCandidateRequest::_internal_mutable_candidate() {
  
  return _impl_.candidate_.Mutable(GetArenaForAllocation());
}
inline std::string* SendIceCandidateRequest::release_candidate() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SendIceCandidateRequest.candidate)
  return _impl_.candidate_.Release();
}
inline void SendIceCandidateRequest::set_allocated_candidate(std::string* candidate) {
  if (candidate != nullptr) {
    
  } else {
    
  }
  _impl_.candidate_.SetAllocated(candidate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.candidate_.IsDefault()) {
    _impl_.candidate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SendIceCandidateRequest.candidate)
}

// -------------------------------------------------------------------

// SendIceCandidateResponse

// string client_identity = 1;
inline void SendIceCandidateResponse::clear_client_identity() {
  _impl_.client_identity_.ClearToEmpty();
}
inline const std::string& SendIceCandidateResponse::client_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SendIceCandidateResponse.client_identity)
  return _internal_client_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendIceCandidateResponse::set_client_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SendIceCandidateResponse.client_identity)
}
inline std::string* SendIceCandidateResponse::mutable_client_identity() {
  std::string* _s = _internal_mutable_client_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SendIceCandidateResponse.client_identity)
  return _s;
}
inline const std::string& SendIceCandidateResponse::_internal_client_identity() const {
  return _impl_.client_identity_.Get();
}
inline void SendIceCandidateResponse::_internal_set_client_identity(const std::string& value) {
  
  _impl_.client_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SendIceCandidateResponse::_internal_mutable_client_identity() {
  
  return _impl_.client_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SendIceCandidateResponse::release_client_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SendIceCandidateResponse.client_identity)
  return _impl_.client_identity_.Release();
}
inline void SendIceCandidateResponse::set_allocated_client_identity(std::string* client_identity) {
  if (client_identity != nullptr) {
    
  } else {
    
  }
  _impl_.client_identity_.SetAllocated(client_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_identity_.IsDefault()) {
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SendIceCandidateResponse.client_identity)
}

// string candidate = 2;
inline void SendIceCandidateResponse::clear_candidate() {
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& SendIceCandidateResponse::candidate() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SendIceCandidateResponse.candidate)
  return _internal_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendIceCandidateResponse::set_candidate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.candidate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SendIceCandidateResponse.candidate)
}
inline std::string* SendIceCandidateResponse::mutable_candidate() {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SendIceCandidateResponse.candidate)
  return _s;
}
inline const std::string& SendIceCandidateResponse::_internal_candidate() const {
  return _impl_.candidate_.Get();
}
inline void SendIceCandidateResponse::_internal_set_candidate(const std::string& value) {
  
  _impl_.candidate_.Set(value, GetArenaForAllocation());
}
inline std::string* SendIceCandidateResponse::_internal_mutable_candidate() {
  
  return _impl_.candidate_.Mutable(GetArenaForAllocation());
}
inline std::string* SendIceCandidateResponse::release_candidate() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SendIceCandidateResponse.candidate)
  return _impl_.candidate_.Release();
}
inline void SendIceCandidateResponse::set_allocated_candidate(std::string* candidate) {
  if (candidate != nullptr) {
    
  } else {
    
  }
  _impl_.candidate_.SetAllocated(candidate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.candidate_.IsDefault()) {
    _impl_.candidate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SendIceCandidateResponse.candidate)
}

// -------------------------------------------------------------------

// GetIceCandidateRequest

// string client_identity = 1;
inline void GetIceCandidateRequest::clear_client_identity() {
  _impl_.client_identity_.ClearToEmpty();
}
inline const std::string& GetIceCandidateRequest::client_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.GetIceCandidateRequest.client_identity)
  return _internal_client_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIceCandidateRequest::set_client_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.GetIceCandidateRequest.client_identity)
}
inline std::string* GetIceCandidateRequest::mutable_client_identity() {
  std::string* _s = _internal_mutable_client_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.GetIceCandidateRequest.client_identity)
  return _s;
}
inline const std::string& GetIceCandidateRequest::_internal_client_identity() const {
  return _impl_.client_identity_.Get();
}
inline void GetIceCandidateRequest::_internal_set_client_identity(const std::string& value) {
  
  _impl_.client_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIceCandidateRequest::_internal_mutable_client_identity() {
  
  return _impl_.client_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* GetIceCandidateRequest::release_client_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.GetIceCandidateRequest.client_identity)
  return _impl_.client_identity_.Release();
}
inline void GetIceCandidateRequest::set_allocated_client_identity(std::string* client_identity) {
  if (client_identity != nullptr) {
    
  } else {
    
  }
  _impl_.client_identity_.SetAllocated(client_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_identity_.IsDefault()) {
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.GetIceCandidateRequest.client_identity)
}

// string candidate = 2;
inline void GetIceCandidateRequest::clear_candidate() {
  _impl_.candidate_.ClearToEmpty();
}
inline const std::string& GetIceCandidateRequest::candidate() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.GetIceCandidateRequest.candidate)
  return _internal_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIceCandidateRequest::set_candidate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.candidate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.GetIceCandidateRequest.candidate)
}
inline std::string* GetIceCandidateRequest::mutable_candidate() {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.GetIceCandidateRequest.candidate)
  return _s;
}
inline const std::string& GetIceCandidateRequest::_internal_candidate() const {
  return _impl_.candidate_.Get();
}
inline void GetIceCandidateRequest::_internal_set_candidate(const std::string& value) {
  
  _impl_.candidate_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIceCandidateRequest::_internal_mutable_candidate() {
  
  return _impl_.candidate_.Mutable(GetArenaForAllocation());
}
inline std::string* GetIceCandidateRequest::release_candidate() {
  // @@protoc_insertion_point(field_release:v6.services.pub.GetIceCandidateRequest.candidate)
  return _impl_.candidate_.Release();
}
inline void GetIceCandidateRequest::set_allocated_candidate(std::string* candidate) {
  if (candidate != nullptr) {
    
  } else {
    
  }
  _impl_.candidate_.SetAllocated(candidate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.candidate_.IsDefault()) {
    _impl_.candidate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.GetIceCandidateRequest.candidate)
}

// -------------------------------------------------------------------

// GetIceCandidateResponse

// string client_identity = 1;
inline void GetIceCandidateResponse::clear_client_identity() {
  _impl_.client_identity_.ClearToEmpty();
}
inline const std::string& GetIceCandidateResponse::client_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.GetIceCandidateResponse.client_identity)
  return _internal_client_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetIceCandidateResponse::set_client_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.GetIceCandidateResponse.client_identity)
}
inline std::string* GetIceCandidateResponse::mutable_client_identity() {
  std::string* _s = _internal_mutable_client_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.GetIceCandidateResponse.client_identity)
  return _s;
}
inline const std::string& GetIceCandidateResponse::_internal_client_identity() const {
  return _impl_.client_identity_.Get();
}
inline void GetIceCandidateResponse::_internal_set_client_identity(const std::string& value) {
  
  _impl_.client_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIceCandidateResponse::_internal_mutable_client_identity() {
  
  return _impl_.client_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* GetIceCandidateResponse::release_client_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.GetIceCandidateResponse.client_identity)
  return _impl_.client_identity_.Release();
}
inline void GetIceCandidateResponse::set_allocated_client_identity(std::string* client_identity) {
  if (client_identity != nullptr) {
    
  } else {
    
  }
  _impl_.client_identity_.SetAllocated(client_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_identity_.IsDefault()) {
    _impl_.client_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.GetIceCandidateResponse.client_identity)
}

// repeated string candidate = 2;
inline int GetIceCandidateResponse::_internal_candidate_size() const {
  return _impl_.candidate_.size();
}
inline int GetIceCandidateResponse::candidate_size() const {
  return _internal_candidate_size();
}
inline void GetIceCandidateResponse::clear_candidate() {
  _impl_.candidate_.Clear();
}
inline std::string* GetIceCandidateResponse::add_candidate() {
  std::string* _s = _internal_add_candidate();
  // @@protoc_insertion_point(field_add_mutable:v6.services.pub.GetIceCandidateResponse.candidate)
  return _s;
}
inline const std::string& GetIceCandidateResponse::_internal_candidate(int index) const {
  return _impl_.candidate_.Get(index);
}
inline const std::string& GetIceCandidateResponse::candidate(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.GetIceCandidateResponse.candidate)
  return _internal_candidate(index);
}
inline std::string* GetIceCandidateResponse::mutable_candidate(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.GetIceCandidateResponse.candidate)
  return _impl_.candidate_.Mutable(index);
}
inline void GetIceCandidateResponse::set_candidate(int index, const std::string& value) {
  _impl_.candidate_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline void GetIceCandidateResponse::set_candidate(int index, std::string&& value) {
  _impl_.candidate_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline void GetIceCandidateResponse::set_candidate(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.candidate_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline void GetIceCandidateResponse::set_candidate(int index, const char* value, size_t size) {
  _impl_.candidate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline std::string* GetIceCandidateResponse::_internal_add_candidate() {
  return _impl_.candidate_.Add();
}
inline void GetIceCandidateResponse::add_candidate(const std::string& value) {
  _impl_.candidate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline void GetIceCandidateResponse::add_candidate(std::string&& value) {
  _impl_.candidate_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline void GetIceCandidateResponse::add_candidate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.candidate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline void GetIceCandidateResponse::add_candidate(const char* value, size_t size) {
  _impl_.candidate_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v6.services.pub.GetIceCandidateResponse.candidate)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetIceCandidateResponse::candidate() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.GetIceCandidateResponse.candidate)
  return _impl_.candidate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetIceCandidateResponse::mutable_candidate() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.GetIceCandidateResponse.candidate)
  return &_impl_.candidate_;
}

// -------------------------------------------------------------------

// ParseFileSliceResponse

// string content_identity = 1;
inline void ParseFileSliceResponse::clear_content_identity() {
  _impl_.content_identity_.ClearToEmpty();
}
inline const std::string& ParseFileSliceResponse::content_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.content_identity)
  return _internal_content_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParseFileSliceResponse::set_content_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.content_identity)
}
inline std::string* ParseFileSliceResponse::mutable_content_identity() {
  std::string* _s = _internal_mutable_content_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ParseFileSliceResponse.content_identity)
  return _s;
}
inline const std::string& ParseFileSliceResponse::_internal_content_identity() const {
  return _impl_.content_identity_.Get();
}
inline void ParseFileSliceResponse::_internal_set_content_identity(const std::string& value) {
  
  _impl_.content_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* ParseFileSliceResponse::_internal_mutable_content_identity() {
  
  return _impl_.content_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* ParseFileSliceResponse::release_content_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ParseFileSliceResponse.content_identity)
  return _impl_.content_identity_.Release();
}
inline void ParseFileSliceResponse::set_allocated_content_identity(std::string* content_identity) {
  if (content_identity != nullptr) {
    
  } else {
    
  }
  _impl_.content_identity_.SetAllocated(content_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_identity_.IsDefault()) {
    _impl_.content_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ParseFileSliceResponse.content_identity)
}

// repeated string meta_nodes = 2;
inline int ParseFileSliceResponse::_internal_meta_nodes_size() const {
  return _impl_.meta_nodes_.size();
}
inline int ParseFileSliceResponse::meta_nodes_size() const {
  return _internal_meta_nodes_size();
}
inline void ParseFileSliceResponse::clear_meta_nodes() {
  _impl_.meta_nodes_.Clear();
}
inline std::string* ParseFileSliceResponse::add_meta_nodes() {
  std::string* _s = _internal_add_meta_nodes();
  // @@protoc_insertion_point(field_add_mutable:v6.services.pub.ParseFileSliceResponse.meta_nodes)
  return _s;
}
inline const std::string& ParseFileSliceResponse::_internal_meta_nodes(int index) const {
  return _impl_.meta_nodes_.Get(index);
}
inline const std::string& ParseFileSliceResponse::meta_nodes(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.meta_nodes)
  return _internal_meta_nodes(index);
}
inline std::string* ParseFileSliceResponse::mutable_meta_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ParseFileSliceResponse.meta_nodes)
  return _impl_.meta_nodes_.Mutable(index);
}
inline void ParseFileSliceResponse::set_meta_nodes(int index, const std::string& value) {
  _impl_.meta_nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline void ParseFileSliceResponse::set_meta_nodes(int index, std::string&& value) {
  _impl_.meta_nodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline void ParseFileSliceResponse::set_meta_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.meta_nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline void ParseFileSliceResponse::set_meta_nodes(int index, const char* value, size_t size) {
  _impl_.meta_nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline std::string* ParseFileSliceResponse::_internal_add_meta_nodes() {
  return _impl_.meta_nodes_.Add();
}
inline void ParseFileSliceResponse::add_meta_nodes(const std::string& value) {
  _impl_.meta_nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline void ParseFileSliceResponse::add_meta_nodes(std::string&& value) {
  _impl_.meta_nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline void ParseFileSliceResponse::add_meta_nodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.meta_nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline void ParseFileSliceResponse::add_meta_nodes(const char* value, size_t size) {
  _impl_.meta_nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v6.services.pub.ParseFileSliceResponse.meta_nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParseFileSliceResponse::meta_nodes() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.ParseFileSliceResponse.meta_nodes)
  return _impl_.meta_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParseFileSliceResponse::mutable_meta_nodes() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.ParseFileSliceResponse.meta_nodes)
  return &_impl_.meta_nodes_;
}

// repeated string raw_nodes = 3;
inline int ParseFileSliceResponse::_internal_raw_nodes_size() const {
  return _impl_.raw_nodes_.size();
}
inline int ParseFileSliceResponse::raw_nodes_size() const {
  return _internal_raw_nodes_size();
}
inline void ParseFileSliceResponse::clear_raw_nodes() {
  _impl_.raw_nodes_.Clear();
}
inline std::string* ParseFileSliceResponse::add_raw_nodes() {
  std::string* _s = _internal_add_raw_nodes();
  // @@protoc_insertion_point(field_add_mutable:v6.services.pub.ParseFileSliceResponse.raw_nodes)
  return _s;
}
inline const std::string& ParseFileSliceResponse::_internal_raw_nodes(int index) const {
  return _impl_.raw_nodes_.Get(index);
}
inline const std::string& ParseFileSliceResponse::raw_nodes(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.raw_nodes)
  return _internal_raw_nodes(index);
}
inline std::string* ParseFileSliceResponse::mutable_raw_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ParseFileSliceResponse.raw_nodes)
  return _impl_.raw_nodes_.Mutable(index);
}
inline void ParseFileSliceResponse::set_raw_nodes(int index, const std::string& value) {
  _impl_.raw_nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline void ParseFileSliceResponse::set_raw_nodes(int index, std::string&& value) {
  _impl_.raw_nodes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline void ParseFileSliceResponse::set_raw_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline void ParseFileSliceResponse::set_raw_nodes(int index, const char* value, size_t size) {
  _impl_.raw_nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline std::string* ParseFileSliceResponse::_internal_add_raw_nodes() {
  return _impl_.raw_nodes_.Add();
}
inline void ParseFileSliceResponse::add_raw_nodes(const std::string& value) {
  _impl_.raw_nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline void ParseFileSliceResponse::add_raw_nodes(std::string&& value) {
  _impl_.raw_nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline void ParseFileSliceResponse::add_raw_nodes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.raw_nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline void ParseFileSliceResponse::add_raw_nodes(const char* value, size_t size) {
  _impl_.raw_nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v6.services.pub.ParseFileSliceResponse.raw_nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ParseFileSliceResponse::raw_nodes() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.ParseFileSliceResponse.raw_nodes)
  return _impl_.raw_nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ParseFileSliceResponse::mutable_raw_nodes() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.ParseFileSliceResponse.raw_nodes)
  return &_impl_.raw_nodes_;
}

// int64 file_size = 4;
inline void ParseFileSliceResponse::clear_file_size() {
  _impl_.file_size_ = int64_t{0};
}
inline int64_t ParseFileSliceResponse::_internal_file_size() const {
  return _impl_.file_size_;
}
inline int64_t ParseFileSliceResponse::file_size() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.file_size)
  return _internal_file_size();
}
inline void ParseFileSliceResponse::_internal_set_file_size(int64_t value) {
  
  _impl_.file_size_ = value;
}
inline void ParseFileSliceResponse::set_file_size(int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.file_size)
}

// repeated .v6.services.pub.SliceSize sizes = 5;
inline int ParseFileSliceResponse::_internal_sizes_size() const {
  return _impl_.sizes_.size();
}
inline int ParseFileSliceResponse::sizes_size() const {
  return _internal_sizes_size();
}
inline void ParseFileSliceResponse::clear_sizes() {
  _impl_.sizes_.Clear();
}
inline ::v6::services::pub::SliceSize* ParseFileSliceResponse::mutable_sizes(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ParseFileSliceResponse.sizes)
  return _impl_.sizes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceSize >*
ParseFileSliceResponse::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.ParseFileSliceResponse.sizes)
  return &_impl_.sizes_;
}
inline const ::v6::services::pub::SliceSize& ParseFileSliceResponse::_internal_sizes(int index) const {
  return _impl_.sizes_.Get(index);
}
inline const ::v6::services::pub::SliceSize& ParseFileSliceResponse::sizes(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.sizes)
  return _internal_sizes(index);
}
inline ::v6::services::pub::SliceSize* ParseFileSliceResponse::_internal_add_sizes() {
  return _impl_.sizes_.Add();
}
inline ::v6::services::pub::SliceSize* ParseFileSliceResponse::add_sizes() {
  ::v6::services::pub::SliceSize* _add = _internal_add_sizes();
  // @@protoc_insertion_point(field_add:v6.services.pub.ParseFileSliceResponse.sizes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceSize >&
ParseFileSliceResponse::sizes() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.ParseFileSliceResponse.sizes)
  return _impl_.sizes_;
}

// string sha1 = 6;
inline void ParseFileSliceResponse::clear_sha1() {
  _impl_.sha1_.ClearToEmpty();
}
inline const std::string& ParseFileSliceResponse::sha1() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.sha1)
  return _internal_sha1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParseFileSliceResponse::set_sha1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sha1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.sha1)
}
inline std::string* ParseFileSliceResponse::mutable_sha1() {
  std::string* _s = _internal_mutable_sha1();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ParseFileSliceResponse.sha1)
  return _s;
}
inline const std::string& ParseFileSliceResponse::_internal_sha1() const {
  return _impl_.sha1_.Get();
}
inline void ParseFileSliceResponse::_internal_set_sha1(const std::string& value) {
  
  _impl_.sha1_.Set(value, GetArenaForAllocation());
}
inline std::string* ParseFileSliceResponse::_internal_mutable_sha1() {
  
  return _impl_.sha1_.Mutable(GetArenaForAllocation());
}
inline std::string* ParseFileSliceResponse::release_sha1() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ParseFileSliceResponse.sha1)
  return _impl_.sha1_.Release();
}
inline void ParseFileSliceResponse::set_allocated_sha1(std::string* sha1) {
  if (sha1 != nullptr) {
    
  } else {
    
  }
  _impl_.sha1_.SetAllocated(sha1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sha1_.IsDefault()) {
    _impl_.sha1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ParseFileSliceResponse.sha1)
}

// string wcs_etag = 7;
inline void ParseFileSliceResponse::clear_wcs_etag() {
  _impl_.wcs_etag_.ClearToEmpty();
}
inline const std::string& ParseFileSliceResponse::wcs_etag() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.ParseFileSliceResponse.wcs_etag)
  return _internal_wcs_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParseFileSliceResponse::set_wcs_etag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.wcs_etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.ParseFileSliceResponse.wcs_etag)
}
inline std::string* ParseFileSliceResponse::mutable_wcs_etag() {
  std::string* _s = _internal_mutable_wcs_etag();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.ParseFileSliceResponse.wcs_etag)
  return _s;
}
inline const std::string& ParseFileSliceResponse::_internal_wcs_etag() const {
  return _impl_.wcs_etag_.Get();
}
inline void ParseFileSliceResponse::_internal_set_wcs_etag(const std::string& value) {
  
  _impl_.wcs_etag_.Set(value, GetArenaForAllocation());
}
inline std::string* ParseFileSliceResponse::_internal_mutable_wcs_etag() {
  
  return _impl_.wcs_etag_.Mutable(GetArenaForAllocation());
}
inline std::string* ParseFileSliceResponse::release_wcs_etag() {
  // @@protoc_insertion_point(field_release:v6.services.pub.ParseFileSliceResponse.wcs_etag)
  return _impl_.wcs_etag_.Release();
}
inline void ParseFileSliceResponse::set_allocated_wcs_etag(std::string* wcs_etag) {
  if (wcs_etag != nullptr) {
    
  } else {
    
  }
  _impl_.wcs_etag_.SetAllocated(wcs_etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wcs_etag_.IsDefault()) {
    _impl_.wcs_etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.ParseFileSliceResponse.wcs_etag)
}

// -------------------------------------------------------------------

// SliceSize

// int64 start_index = 1;
inline void SliceSize::clear_start_index() {
  _impl_.start_index_ = int64_t{0};
}
inline int64_t SliceSize::_internal_start_index() const {
  return _impl_.start_index_;
}
inline int64_t SliceSize::start_index() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceSize.start_index)
  return _internal_start_index();
}
inline void SliceSize::_internal_set_start_index(int64_t value) {
  
  _impl_.start_index_ = value;
}
inline void SliceSize::set_start_index(int64_t value) {
  _internal_set_start_index(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceSize.start_index)
}

// int64 end_index = 2;
inline void SliceSize::clear_end_index() {
  _impl_.end_index_ = int64_t{0};
}
inline int64_t SliceSize::_internal_end_index() const {
  return _impl_.end_index_;
}
inline int64_t SliceSize::end_index() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceSize.end_index)
  return _internal_end_index();
}
inline void SliceSize::_internal_set_end_index(int64_t value) {
  
  _impl_.end_index_ = value;
}
inline void SliceSize::set_end_index(int64_t value) {
  _internal_set_end_index(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceSize.end_index)
}

// int64 size = 3;
inline void SliceSize::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t SliceSize::_internal_size() const {
  return _impl_.size_;
}
inline int64_t SliceSize::size() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceSize.size)
  return _internal_size();
}
inline void SliceSize::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void SliceSize::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceSize.size)
}

// -------------------------------------------------------------------

// SliceDownloadAddressRequest

// repeated string identity = 1;
inline int SliceDownloadAddressRequest::_internal_identity_size() const {
  return _impl_.identity_.size();
}
inline int SliceDownloadAddressRequest::identity_size() const {
  return _internal_identity_size();
}
inline void SliceDownloadAddressRequest::clear_identity() {
  _impl_.identity_.Clear();
}
inline std::string* SliceDownloadAddressRequest::add_identity() {
  std::string* _s = _internal_add_identity();
  // @@protoc_insertion_point(field_add_mutable:v6.services.pub.SliceDownloadAddressRequest.identity)
  return _s;
}
inline const std::string& SliceDownloadAddressRequest::_internal_identity(int index) const {
  return _impl_.identity_.Get(index);
}
inline const std::string& SliceDownloadAddressRequest::identity(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadAddressRequest.identity)
  return _internal_identity(index);
}
inline std::string* SliceDownloadAddressRequest::mutable_identity(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SliceDownloadAddressRequest.identity)
  return _impl_.identity_.Mutable(index);
}
inline void SliceDownloadAddressRequest::set_identity(int index, const std::string& value) {
  _impl_.identity_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline void SliceDownloadAddressRequest::set_identity(int index, std::string&& value) {
  _impl_.identity_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline void SliceDownloadAddressRequest::set_identity(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.identity_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline void SliceDownloadAddressRequest::set_identity(int index, const char* value, size_t size) {
  _impl_.identity_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline std::string* SliceDownloadAddressRequest::_internal_add_identity() {
  return _impl_.identity_.Add();
}
inline void SliceDownloadAddressRequest::add_identity(const std::string& value) {
  _impl_.identity_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline void SliceDownloadAddressRequest::add_identity(std::string&& value) {
  _impl_.identity_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline void SliceDownloadAddressRequest::add_identity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.identity_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline void SliceDownloadAddressRequest::add_identity(const char* value, size_t size) {
  _impl_.identity_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v6.services.pub.SliceDownloadAddressRequest.identity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SliceDownloadAddressRequest::identity() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.SliceDownloadAddressRequest.identity)
  return _impl_.identity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SliceDownloadAddressRequest::mutable_identity() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.SliceDownloadAddressRequest.identity)
  return &_impl_.identity_;
}

// -------------------------------------------------------------------

// SliceDownloadAddressResponse

// repeated .v6.services.pub.SliceDownloadInfo addresses = 1;
inline int SliceDownloadAddressResponse::_internal_addresses_size() const {
  return _impl_.addresses_.size();
}
inline int SliceDownloadAddressResponse::addresses_size() const {
  return _internal_addresses_size();
}
inline void SliceDownloadAddressResponse::clear_addresses() {
  _impl_.addresses_.Clear();
}
inline ::v6::services::pub::SliceDownloadInfo* SliceDownloadAddressResponse::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SliceDownloadAddressResponse.addresses)
  return _impl_.addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceDownloadInfo >*
SliceDownloadAddressResponse::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:v6.services.pub.SliceDownloadAddressResponse.addresses)
  return &_impl_.addresses_;
}
inline const ::v6::services::pub::SliceDownloadInfo& SliceDownloadAddressResponse::_internal_addresses(int index) const {
  return _impl_.addresses_.Get(index);
}
inline const ::v6::services::pub::SliceDownloadInfo& SliceDownloadAddressResponse::addresses(int index) const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadAddressResponse.addresses)
  return _internal_addresses(index);
}
inline ::v6::services::pub::SliceDownloadInfo* SliceDownloadAddressResponse::_internal_add_addresses() {
  return _impl_.addresses_.Add();
}
inline ::v6::services::pub::SliceDownloadInfo* SliceDownloadAddressResponse::add_addresses() {
  ::v6::services::pub::SliceDownloadInfo* _add = _internal_add_addresses();
  // @@protoc_insertion_point(field_add:v6.services.pub.SliceDownloadAddressResponse.addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v6::services::pub::SliceDownloadInfo >&
SliceDownloadAddressResponse::addresses() const {
  // @@protoc_insertion_point(field_list:v6.services.pub.SliceDownloadAddressResponse.addresses)
  return _impl_.addresses_;
}

// int64 expire_at = 2;
inline void SliceDownloadAddressResponse::clear_expire_at() {
  _impl_.expire_at_ = int64_t{0};
}
inline int64_t SliceDownloadAddressResponse::_internal_expire_at() const {
  return _impl_.expire_at_;
}
inline int64_t SliceDownloadAddressResponse::expire_at() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadAddressResponse.expire_at)
  return _internal_expire_at();
}
inline void SliceDownloadAddressResponse::_internal_set_expire_at(int64_t value) {
  
  _impl_.expire_at_ = value;
}
inline void SliceDownloadAddressResponse::set_expire_at(int64_t value) {
  _internal_set_expire_at(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadAddressResponse.expire_at)
}

// string request_address = 3;
inline void SliceDownloadAddressResponse::clear_request_address() {
  _impl_.request_address_.ClearToEmpty();
}
inline const std::string& SliceDownloadAddressResponse::request_address() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadAddressResponse.request_address)
  return _internal_request_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceDownloadAddressResponse::set_request_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.request_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadAddressResponse.request_address)
}
inline std::string* SliceDownloadAddressResponse::mutable_request_address() {
  std::string* _s = _internal_mutable_request_address();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SliceDownloadAddressResponse.request_address)
  return _s;
}
inline const std::string& SliceDownloadAddressResponse::_internal_request_address() const {
  return _impl_.request_address_.Get();
}
inline void SliceDownloadAddressResponse::_internal_set_request_address(const std::string& value) {
  
  _impl_.request_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SliceDownloadAddressResponse::_internal_mutable_request_address() {
  
  return _impl_.request_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SliceDownloadAddressResponse::release_request_address() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SliceDownloadAddressResponse.request_address)
  return _impl_.request_address_.Release();
}
inline void SliceDownloadAddressResponse::set_allocated_request_address(std::string* request_address) {
  if (request_address != nullptr) {
    
  } else {
    
  }
  _impl_.request_address_.SetAllocated(request_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.request_address_.IsDefault()) {
    _impl_.request_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SliceDownloadAddressResponse.request_address)
}

// -------------------------------------------------------------------

// SliceDownloadInfo

// string identity = 1;
inline void SliceDownloadInfo::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& SliceDownloadInfo::identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadInfo.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceDownloadInfo::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadInfo.identity)
}
inline std::string* SliceDownloadInfo::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SliceDownloadInfo.identity)
  return _s;
}
inline const std::string& SliceDownloadInfo::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void SliceDownloadInfo::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* SliceDownloadInfo::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* SliceDownloadInfo::release_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SliceDownloadInfo.identity)
  return _impl_.identity_.Release();
}
inline void SliceDownloadInfo::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SliceDownloadInfo.identity)
}

// string download_address = 2;
inline void SliceDownloadInfo::clear_download_address() {
  _impl_.download_address_.ClearToEmpty();
}
inline const std::string& SliceDownloadInfo::download_address() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadInfo.download_address)
  return _internal_download_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceDownloadInfo::set_download_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.download_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadInfo.download_address)
}
inline std::string* SliceDownloadInfo::mutable_download_address() {
  std::string* _s = _internal_mutable_download_address();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SliceDownloadInfo.download_address)
  return _s;
}
inline const std::string& SliceDownloadInfo::_internal_download_address() const {
  return _impl_.download_address_.Get();
}
inline void SliceDownloadInfo::_internal_set_download_address(const std::string& value) {
  
  _impl_.download_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SliceDownloadInfo::_internal_mutable_download_address() {
  
  return _impl_.download_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SliceDownloadInfo::release_download_address() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SliceDownloadInfo.download_address)
  return _impl_.download_address_.Release();
}
inline void SliceDownloadInfo::set_allocated_download_address(std::string* download_address) {
  if (download_address != nullptr) {
    
  } else {
    
  }
  _impl_.download_address_.SetAllocated(download_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.download_address_.IsDefault()) {
    _impl_.download_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SliceDownloadInfo.download_address)
}

// string download_token = 3;
inline void SliceDownloadInfo::clear_download_token() {
  _impl_.download_token_.ClearToEmpty();
}
inline const std::string& SliceDownloadInfo::download_token() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SliceDownloadInfo.download_token)
  return _internal_download_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceDownloadInfo::set_download_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.download_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SliceDownloadInfo.download_token)
}
inline std::string* SliceDownloadInfo::mutable_download_token() {
  std::string* _s = _internal_mutable_download_token();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SliceDownloadInfo.download_token)
  return _s;
}
inline const std::string& SliceDownloadInfo::_internal_download_token() const {
  return _impl_.download_token_.Get();
}
inline void SliceDownloadInfo::_internal_set_download_token(const std::string& value) {
  
  _impl_.download_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SliceDownloadInfo::_internal_mutable_download_token() {
  
  return _impl_.download_token_.Mutable(GetArenaForAllocation());
}
inline std::string* SliceDownloadInfo::release_download_token() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SliceDownloadInfo.download_token)
  return _impl_.download_token_.Release();
}
inline void SliceDownloadInfo::set_allocated_download_token(std::string* download_token) {
  if (download_token != nullptr) {
    
  } else {
    
  }
  _impl_.download_token_.SetAllocated(download_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.download_token_.IsDefault()) {
    _impl_.download_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SliceDownloadInfo.download_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pub
}  // namespace services
}  // namespace v6

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_public_5fuser_5ffile_2eproto
