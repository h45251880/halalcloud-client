// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user_svc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_5fsvc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_5fsvc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_5fsvc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_5fsvc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_5fsvc_2eproto;
namespace v6 {
namespace services {
namespace pub {
class LastLoginResponse;
struct LastLoginResponseDefaultTypeInternal;
extern LastLoginResponseDefaultTypeInternal _LastLoginResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class OauthTokenCheckResponse;
struct OauthTokenCheckResponseDefaultTypeInternal;
extern OauthTokenCheckResponseDefaultTypeInternal _OauthTokenCheckResponse_default_instance_;
class OauthTokenResponse;
struct OauthTokenResponseDefaultTypeInternal;
extern OauthTokenResponseDefaultTypeInternal _OauthTokenResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class SmsVeifyCodeSendRequest;
struct SmsVeifyCodeSendRequestDefaultTypeInternal;
extern SmsVeifyCodeSendRequestDefaultTypeInternal _SmsVeifyCodeSendRequest_default_instance_;
class SmsVeifyCodeSendRequestNotUser;
struct SmsVeifyCodeSendRequestNotUserDefaultTypeInternal;
extern SmsVeifyCodeSendRequestNotUserDefaultTypeInternal _SmsVeifyCodeSendRequestNotUser_default_instance_;
class SmsVeifyCodeSendResponse;
struct SmsVeifyCodeSendResponseDefaultTypeInternal;
extern SmsVeifyCodeSendResponseDefaultTypeInternal _SmsVeifyCodeSendResponse_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace pub
}  // namespace services
}  // namespace v6
PROTOBUF_NAMESPACE_OPEN
template<> ::v6::services::pub::LastLoginResponse* Arena::CreateMaybeMessage<::v6::services::pub::LastLoginResponse>(Arena*);
template<> ::v6::services::pub::LoginRequest* Arena::CreateMaybeMessage<::v6::services::pub::LoginRequest>(Arena*);
template<> ::v6::services::pub::LoginResponse* Arena::CreateMaybeMessage<::v6::services::pub::LoginResponse>(Arena*);
template<> ::v6::services::pub::OauthTokenCheckResponse* Arena::CreateMaybeMessage<::v6::services::pub::OauthTokenCheckResponse>(Arena*);
template<> ::v6::services::pub::OauthTokenResponse* Arena::CreateMaybeMessage<::v6::services::pub::OauthTokenResponse>(Arena*);
template<> ::v6::services::pub::RegisterRequest* Arena::CreateMaybeMessage<::v6::services::pub::RegisterRequest>(Arena*);
template<> ::v6::services::pub::SmsVeifyCodeSendRequest* Arena::CreateMaybeMessage<::v6::services::pub::SmsVeifyCodeSendRequest>(Arena*);
template<> ::v6::services::pub::SmsVeifyCodeSendRequestNotUser* Arena::CreateMaybeMessage<::v6::services::pub::SmsVeifyCodeSendRequestNotUser>(Arena*);
template<> ::v6::services::pub::SmsVeifyCodeSendResponse* Arena::CreateMaybeMessage<::v6::services::pub::SmsVeifyCodeSendResponse>(Arena*);
template<> ::v6::services::pub::Token* Arena::CreateMaybeMessage<::v6::services::pub::Token>(Arena*);
template<> ::v6::services::pub::User* Arena::CreateMaybeMessage<::v6::services::pub::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v6 {
namespace services {
namespace pub {

// ===================================================================

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kPasswordFieldNumber = 6,
    kNameFieldNumber = 7,
    kAddonFieldNumber = 8,
    kHashFieldNumber = 10,
    kIconFieldNumber = 11,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 3,
    kUpdateTsFieldNumber = 5,
    kCreateTsFieldNumber = 9,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string password = 6;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string name = 7;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string addon = 8;
  void clear_addon();
  const std::string& addon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addon();
  PROTOBUF_NODISCARD std::string* release_addon();
  void set_allocated_addon(std::string* addon);
  private:
  const std::string& _internal_addon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addon(const std::string& value);
  std::string* _internal_mutable_addon();
  public:

  // string hash = 10;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string icon = 11;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 status = 3;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // int64 update_ts = 5;
  void clear_update_ts();
  int64_t update_ts() const;
  void set_update_ts(int64_t value);
  private:
  int64_t _internal_update_ts() const;
  void _internal_set_update_ts(int64_t value);
  public:

  // int64 create_ts = 9;
  void clear_create_ts();
  int64_t create_ts() const;
  void set_create_ts(int64_t value);
  private:
  int64_t _internal_create_ts() const;
  void _internal_set_create_ts(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
    int32_t type_;
    int32_t status_;
    int64_t update_ts_;
    int64_t create_ts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kAddonFieldNumber = 3,
    kInputFieldNumber = 4,
    kTypeFieldNumber = 5,
    kCallbackFieldNumber = 6,
    kReturnUrlFieldNumber = 7,
    kCaptchaFieldNumber = 9,
    kStateFieldNumber = 10,
    kCountryCodeFieldNumber = 11,
    kReturnTypeFieldNumber = 8,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string addon = 3;
  void clear_addon();
  const std::string& addon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addon();
  PROTOBUF_NODISCARD std::string* release_addon();
  void set_allocated_addon(std::string* addon);
  private:
  const std::string& _internal_addon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addon(const std::string& value);
  std::string* _internal_mutable_addon();
  public:

  // string input = 4;
  void clear_input();
  const std::string& input() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input();
  PROTOBUF_NODISCARD std::string* release_input();
  void set_allocated_input(std::string* input);
  private:
  const std::string& _internal_input() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input(const std::string& value);
  std::string* _internal_mutable_input();
  public:

  // string type = 5;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string callback = 6;
  void clear_callback();
  const std::string& callback() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callback(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callback();
  PROTOBUF_NODISCARD std::string* release_callback();
  void set_allocated_callback(std::string* callback);
  private:
  const std::string& _internal_callback() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callback(const std::string& value);
  std::string* _internal_mutable_callback();
  public:

  // string return_url = 7;
  void clear_return_url();
  const std::string& return_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_url();
  PROTOBUF_NODISCARD std::string* release_return_url();
  void set_allocated_return_url(std::string* return_url);
  private:
  const std::string& _internal_return_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_url(const std::string& value);
  std::string* _internal_mutable_return_url();
  public:

  // string captcha = 9;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string state = 10;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string country_code = 11;
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // int32 return_type = 8;
  void clear_return_type();
  int32_t return_type() const;
  void set_return_type(int32_t value);
  private:
  int32_t _internal_return_type() const;
  void _internal_set_return_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callback_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    int32_t return_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 4,
    kTokenFieldNumber = 1,
    kUserFieldNumber = 2,
    kLastLoginFieldNumber = 3,
  };
  // string state = 4;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // .v6.services.pub.Token token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::v6::services::pub::Token& token() const;
  PROTOBUF_NODISCARD ::v6::services::pub::Token* release_token();
  ::v6::services::pub::Token* mutable_token();
  void set_allocated_token(::v6::services::pub::Token* token);
  private:
  const ::v6::services::pub::Token& _internal_token() const;
  ::v6::services::pub::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::v6::services::pub::Token* token);
  ::v6::services::pub::Token* unsafe_arena_release_token();

  // .v6.services.pub.User user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::v6::services::pub::User& user() const;
  PROTOBUF_NODISCARD ::v6::services::pub::User* release_user();
  ::v6::services::pub::User* mutable_user();
  void set_allocated_user(::v6::services::pub::User* user);
  private:
  const ::v6::services::pub::User& _internal_user() const;
  ::v6::services::pub::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::v6::services::pub::User* user);
  ::v6::services::pub::User* unsafe_arena_release_user();

  // .v6.services.pub.LastLoginResponse last_login = 3;
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  const ::v6::services::pub::LastLoginResponse& last_login() const;
  PROTOBUF_NODISCARD ::v6::services::pub::LastLoginResponse* release_last_login();
  ::v6::services::pub::LastLoginResponse* mutable_last_login();
  void set_allocated_last_login(::v6::services::pub::LastLoginResponse* last_login);
  private:
  const ::v6::services::pub::LastLoginResponse& _internal_last_login() const;
  ::v6::services::pub::LastLoginResponse* _internal_mutable_last_login();
  public:
  void unsafe_arena_set_allocated_last_login(
      ::v6::services::pub::LastLoginResponse* last_login);
  ::v6::services::pub::LastLoginResponse* unsafe_arena_release_last_login();

  // @@protoc_insertion_point(class_scope:v6.services.pub.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    ::v6::services::pub::Token* token_;
    ::v6::services::pub::User* user_;
    ::v6::services::pub::LastLoginResponse* last_login_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class LastLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.LastLoginResponse) */ {
 public:
  inline LastLoginResponse() : LastLoginResponse(nullptr) {}
  ~LastLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LastLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LastLoginResponse(const LastLoginResponse& from);
  LastLoginResponse(LastLoginResponse&& from) noexcept
    : LastLoginResponse() {
    *this = ::std::move(from);
  }

  inline LastLoginResponse& operator=(const LastLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastLoginResponse& operator=(LastLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LastLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LastLoginResponse* internal_default_instance() {
    return reinterpret_cast<const LastLoginResponse*>(
               &_LastLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LastLoginResponse& a, LastLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LastLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LastLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LastLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LastLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LastLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LastLoginResponse& from) {
    LastLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LastLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.LastLoginResponse";
  }
  protected:
  explicit LastLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kLastLoginIpFieldNumber = 3,
    kLastLoginDeviceFieldNumber = 4,
    kLastLoginTsFieldNumber = 2,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string last_login_ip = 3;
  void clear_last_login_ip();
  const std::string& last_login_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_login_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_login_ip();
  PROTOBUF_NODISCARD std::string* release_last_login_ip();
  void set_allocated_last_login_ip(std::string* last_login_ip);
  private:
  const std::string& _internal_last_login_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_login_ip(const std::string& value);
  std::string* _internal_mutable_last_login_ip();
  public:

  // string last_login_device = 4;
  void clear_last_login_device();
  const std::string& last_login_device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_login_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_login_device();
  PROTOBUF_NODISCARD std::string* release_last_login_device();
  void set_allocated_last_login_device(std::string* last_login_device);
  private:
  const std::string& _internal_last_login_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_login_device(const std::string& value);
  std::string* _internal_mutable_last_login_device();
  public:

  // int64 last_login_ts = 2;
  void clear_last_login_ts();
  int64_t last_login_ts() const;
  void set_last_login_ts(int64_t value);
  private:
  int64_t _internal_last_login_ts() const;
  void _internal_set_last_login_ts(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.LastLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_login_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_login_device_;
    int64_t last_login_ts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kUserIdentityFieldNumber = 2,
    kDeviceFieldNumber = 3,
    kAccessTokenFieldNumber = 5,
    kRefreshTokenFieldNumber = 6,
    kUpdateTsFieldNumber = 7,
    kAccessTokenExpireTsFieldNumber = 8,
    kRefreshTokenExpireTsFieldNumber = 9,
    kVersionFieldNumber = 4,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string user_identity = 2;
  void clear_user_identity();
  const std::string& user_identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_identity();
  PROTOBUF_NODISCARD std::string* release_user_identity();
  void set_allocated_user_identity(std::string* user_identity);
  private:
  const std::string& _internal_user_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_identity(const std::string& value);
  std::string* _internal_mutable_user_identity();
  public:

  // string device = 3;
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // string access_token = 5;
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // string refresh_token = 6;
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // int64 update_ts = 7;
  void clear_update_ts();
  int64_t update_ts() const;
  void set_update_ts(int64_t value);
  private:
  int64_t _internal_update_ts() const;
  void _internal_set_update_ts(int64_t value);
  public:

  // int64 access_token_expire_ts = 8;
  void clear_access_token_expire_ts();
  int64_t access_token_expire_ts() const;
  void set_access_token_expire_ts(int64_t value);
  private:
  int64_t _internal_access_token_expire_ts() const;
  void _internal_set_access_token_expire_ts(int64_t value);
  public:

  // int64 refresh_token_expire_ts = 9;
  void clear_refresh_token_expire_ts();
  int64_t refresh_token_expire_ts() const;
  void set_refresh_token_expire_ts(int64_t value);
  private:
  int64_t _internal_refresh_token_expire_ts() const;
  void _internal_set_refresh_token_expire_ts(int64_t value);
  public:

  // int32 version = 4;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
    int64_t update_ts_;
    int64_t access_token_expire_ts_;
    int64_t refresh_token_expire_ts_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kCaptchaFieldNumber = 3,
    kEmailFieldNumber = 5,
    kSmsCaptchaFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string captcha = 3;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string email = 5;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string sms_captcha = 6;
  void clear_sms_captcha();
  const std::string& sms_captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sms_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sms_captcha();
  PROTOBUF_NODISCARD std::string* release_sms_captcha();
  void set_allocated_sms_captcha(std::string* sms_captcha);
  private:
  const std::string& _internal_sms_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sms_captcha(const std::string& value);
  std::string* _internal_mutable_sms_captcha();
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sms_captcha_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class SmsVeifyCodeSendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SmsVeifyCodeSendRequest) */ {
 public:
  inline SmsVeifyCodeSendRequest() : SmsVeifyCodeSendRequest(nullptr) {}
  ~SmsVeifyCodeSendRequest() override;
  explicit PROTOBUF_CONSTEXPR SmsVeifyCodeSendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmsVeifyCodeSendRequest(const SmsVeifyCodeSendRequest& from);
  SmsVeifyCodeSendRequest(SmsVeifyCodeSendRequest&& from) noexcept
    : SmsVeifyCodeSendRequest() {
    *this = ::std::move(from);
  }

  inline SmsVeifyCodeSendRequest& operator=(const SmsVeifyCodeSendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmsVeifyCodeSendRequest& operator=(SmsVeifyCodeSendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmsVeifyCodeSendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmsVeifyCodeSendRequest* internal_default_instance() {
    return reinterpret_cast<const SmsVeifyCodeSendRequest*>(
               &_SmsVeifyCodeSendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SmsVeifyCodeSendRequest& a, SmsVeifyCodeSendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SmsVeifyCodeSendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmsVeifyCodeSendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmsVeifyCodeSendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmsVeifyCodeSendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmsVeifyCodeSendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmsVeifyCodeSendRequest& from) {
    SmsVeifyCodeSendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmsVeifyCodeSendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SmsVeifyCodeSendRequest";
  }
  protected:
  explicit SmsVeifyCodeSendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptchaFieldNumber = 1,
    kAddonFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string captcha = 1;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string addon = 3;
  void clear_addon();
  const std::string& addon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addon();
  PROTOBUF_NODISCARD std::string* release_addon();
  void set_allocated_addon(std::string* addon);
  private:
  const std::string& _internal_addon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addon(const std::string& value);
  std::string* _internal_mutable_addon();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SmsVeifyCodeSendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addon_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class SmsVeifyCodeSendRequestNotUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SmsVeifyCodeSendRequestNotUser) */ {
 public:
  inline SmsVeifyCodeSendRequestNotUser() : SmsVeifyCodeSendRequestNotUser(nullptr) {}
  ~SmsVeifyCodeSendRequestNotUser() override;
  explicit PROTOBUF_CONSTEXPR SmsVeifyCodeSendRequestNotUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmsVeifyCodeSendRequestNotUser(const SmsVeifyCodeSendRequestNotUser& from);
  SmsVeifyCodeSendRequestNotUser(SmsVeifyCodeSendRequestNotUser&& from) noexcept
    : SmsVeifyCodeSendRequestNotUser() {
    *this = ::std::move(from);
  }

  inline SmsVeifyCodeSendRequestNotUser& operator=(const SmsVeifyCodeSendRequestNotUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmsVeifyCodeSendRequestNotUser& operator=(SmsVeifyCodeSendRequestNotUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmsVeifyCodeSendRequestNotUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmsVeifyCodeSendRequestNotUser* internal_default_instance() {
    return reinterpret_cast<const SmsVeifyCodeSendRequestNotUser*>(
               &_SmsVeifyCodeSendRequestNotUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SmsVeifyCodeSendRequestNotUser& a, SmsVeifyCodeSendRequestNotUser& b) {
    a.Swap(&b);
  }
  inline void Swap(SmsVeifyCodeSendRequestNotUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmsVeifyCodeSendRequestNotUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmsVeifyCodeSendRequestNotUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmsVeifyCodeSendRequestNotUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmsVeifyCodeSendRequestNotUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmsVeifyCodeSendRequestNotUser& from) {
    SmsVeifyCodeSendRequestNotUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmsVeifyCodeSendRequestNotUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SmsVeifyCodeSendRequestNotUser";
  }
  protected:
  explicit SmsVeifyCodeSendRequestNotUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptchaFieldNumber = 1,
    kAddonFieldNumber = 3,
    kCountryCodeFieldNumber = 4,
    kPhoneFieldNumber = 5,
    kTypeFieldNumber = 2,
  };
  // string captcha = 1;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string addon = 3;
  void clear_addon();
  const std::string& addon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addon();
  PROTOBUF_NODISCARD std::string* release_addon();
  void set_allocated_addon(std::string* addon);
  private:
  const std::string& _internal_addon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addon(const std::string& value);
  std::string* _internal_mutable_addon();
  public:

  // string country_code = 4;
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // string phone = 5;
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SmsVeifyCodeSendRequestNotUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class SmsVeifyCodeSendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.SmsVeifyCodeSendResponse) */ {
 public:
  inline SmsVeifyCodeSendResponse() : SmsVeifyCodeSendResponse(nullptr) {}
  ~SmsVeifyCodeSendResponse() override;
  explicit PROTOBUF_CONSTEXPR SmsVeifyCodeSendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmsVeifyCodeSendResponse(const SmsVeifyCodeSendResponse& from);
  SmsVeifyCodeSendResponse(SmsVeifyCodeSendResponse&& from) noexcept
    : SmsVeifyCodeSendResponse() {
    *this = ::std::move(from);
  }

  inline SmsVeifyCodeSendResponse& operator=(const SmsVeifyCodeSendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmsVeifyCodeSendResponse& operator=(SmsVeifyCodeSendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmsVeifyCodeSendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmsVeifyCodeSendResponse* internal_default_instance() {
    return reinterpret_cast<const SmsVeifyCodeSendResponse*>(
               &_SmsVeifyCodeSendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SmsVeifyCodeSendResponse& a, SmsVeifyCodeSendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SmsVeifyCodeSendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmsVeifyCodeSendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmsVeifyCodeSendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmsVeifyCodeSendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmsVeifyCodeSendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmsVeifyCodeSendResponse& from) {
    SmsVeifyCodeSendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmsVeifyCodeSendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.SmsVeifyCodeSendResponse";
  }
  protected:
  explicit SmsVeifyCodeSendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptchaFieldNumber = 1,
    kAddonFieldNumber = 3,
    kExpireTsFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string captcha = 1;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string addon = 3;
  void clear_addon();
  const std::string& addon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addon();
  PROTOBUF_NODISCARD std::string* release_addon();
  void set_allocated_addon(std::string* addon);
  private:
  const std::string& _internal_addon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addon(const std::string& value);
  std::string* _internal_mutable_addon();
  public:

  // int64 expire_ts = 4;
  void clear_expire_ts();
  int64_t expire_ts() const;
  void set_expire_ts(int64_t value);
  private:
  int64_t _internal_expire_ts() const;
  void _internal_set_expire_ts(int64_t value);
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.SmsVeifyCodeSendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addon_;
    int64_t expire_ts_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class OauthTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.OauthTokenResponse) */ {
 public:
  inline OauthTokenResponse() : OauthTokenResponse(nullptr) {}
  ~OauthTokenResponse() override;
  explicit PROTOBUF_CONSTEXPR OauthTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OauthTokenResponse(const OauthTokenResponse& from);
  OauthTokenResponse(OauthTokenResponse&& from) noexcept
    : OauthTokenResponse() {
    *this = ::std::move(from);
  }

  inline OauthTokenResponse& operator=(const OauthTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OauthTokenResponse& operator=(OauthTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OauthTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OauthTokenResponse* internal_default_instance() {
    return reinterpret_cast<const OauthTokenResponse*>(
               &_OauthTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OauthTokenResponse& a, OauthTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OauthTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OauthTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OauthTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OauthTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OauthTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OauthTokenResponse& from) {
    OauthTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OauthTokenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.OauthTokenResponse";
  }
  protected:
  explicit OauthTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kAddonFieldNumber = 2,
    kInputFieldNumber = 3,
    kTypeFieldNumber = 4,
    kCallbackFieldNumber = 5,
    kReturnUrlFieldNumber = 6,
    kCaptchaFieldNumber = 8,
    kStateFieldNumber = 9,
    kReturnTypeFieldNumber = 7,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string addon = 2;
  void clear_addon();
  const std::string& addon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addon();
  PROTOBUF_NODISCARD std::string* release_addon();
  void set_allocated_addon(std::string* addon);
  private:
  const std::string& _internal_addon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addon(const std::string& value);
  std::string* _internal_mutable_addon();
  public:

  // string input = 3;
  void clear_input();
  const std::string& input() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_input(ArgT0&& arg0, ArgT... args);
  std::string* mutable_input();
  PROTOBUF_NODISCARD std::string* release_input();
  void set_allocated_input(std::string* input);
  private:
  const std::string& _internal_input() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_input(const std::string& value);
  std::string* _internal_mutable_input();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string callback = 5;
  void clear_callback();
  const std::string& callback() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callback(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callback();
  PROTOBUF_NODISCARD std::string* release_callback();
  void set_allocated_callback(std::string* callback);
  private:
  const std::string& _internal_callback() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callback(const std::string& value);
  std::string* _internal_mutable_callback();
  public:

  // string return_url = 6;
  void clear_return_url();
  const std::string& return_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_return_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_return_url();
  PROTOBUF_NODISCARD std::string* release_return_url();
  void set_allocated_return_url(std::string* return_url);
  private:
  const std::string& _internal_return_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_return_url(const std::string& value);
  std::string* _internal_mutable_return_url();
  public:

  // string captcha = 8;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string state = 9;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // int32 return_type = 7;
  void clear_return_type();
  int32_t return_type() const;
  void set_return_type(int32_t value);
  private:
  int32_t _internal_return_type() const;
  void _internal_set_return_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.OauthTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callback_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr return_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    int32_t return_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// -------------------------------------------------------------------

class OauthTokenCheckResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v6.services.pub.OauthTokenCheckResponse) */ {
 public:
  inline OauthTokenCheckResponse() : OauthTokenCheckResponse(nullptr) {}
  ~OauthTokenCheckResponse() override;
  explicit PROTOBUF_CONSTEXPR OauthTokenCheckResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OauthTokenCheckResponse(const OauthTokenCheckResponse& from);
  OauthTokenCheckResponse(OauthTokenCheckResponse&& from) noexcept
    : OauthTokenCheckResponse() {
    *this = ::std::move(from);
  }

  inline OauthTokenCheckResponse& operator=(const OauthTokenCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OauthTokenCheckResponse& operator=(OauthTokenCheckResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OauthTokenCheckResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OauthTokenCheckResponse* internal_default_instance() {
    return reinterpret_cast<const OauthTokenCheckResponse*>(
               &_OauthTokenCheckResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OauthTokenCheckResponse& a, OauthTokenCheckResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OauthTokenCheckResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OauthTokenCheckResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OauthTokenCheckResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OauthTokenCheckResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OauthTokenCheckResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OauthTokenCheckResponse& from) {
    OauthTokenCheckResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OauthTokenCheckResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v6.services.pub.OauthTokenCheckResponse";
  }
  protected:
  explicit OauthTokenCheckResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kLoginFieldNumber = 1,
    kOauthFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // string message = 4;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .v6.services.pub.LoginResponse login = 1;
  bool has_login() const;
  private:
  bool _internal_has_login() const;
  public:
  void clear_login();
  const ::v6::services::pub::LoginResponse& login() const;
  PROTOBUF_NODISCARD ::v6::services::pub::LoginResponse* release_login();
  ::v6::services::pub::LoginResponse* mutable_login();
  void set_allocated_login(::v6::services::pub::LoginResponse* login);
  private:
  const ::v6::services::pub::LoginResponse& _internal_login() const;
  ::v6::services::pub::LoginResponse* _internal_mutable_login();
  public:
  void unsafe_arena_set_allocated_login(
      ::v6::services::pub::LoginResponse* login);
  ::v6::services::pub::LoginResponse* unsafe_arena_release_login();

  // .v6.services.pub.OauthTokenResponse oauth = 2;
  bool has_oauth() const;
  private:
  bool _internal_has_oauth() const;
  public:
  void clear_oauth();
  const ::v6::services::pub::OauthTokenResponse& oauth() const;
  PROTOBUF_NODISCARD ::v6::services::pub::OauthTokenResponse* release_oauth();
  ::v6::services::pub::OauthTokenResponse* mutable_oauth();
  void set_allocated_oauth(::v6::services::pub::OauthTokenResponse* oauth);
  private:
  const ::v6::services::pub::OauthTokenResponse& _internal_oauth() const;
  ::v6::services::pub::OauthTokenResponse* _internal_mutable_oauth();
  public:
  void unsafe_arena_set_allocated_oauth(
      ::v6::services::pub::OauthTokenResponse* oauth);
  ::v6::services::pub::OauthTokenResponse* unsafe_arena_release_oauth();

  // int32 status = 3;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v6.services.pub.OauthTokenCheckResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::v6::services::pub::LoginResponse* login_;
    ::v6::services::pub::OauthTokenResponse* oauth_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_5fsvc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// string identity = 1;
inline void User::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& User::identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.User.identity)
}
inline std::string* User::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.User.identity)
  return _s;
}
inline const std::string& User::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void User::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.User.identity)
  return _impl_.identity_.Release();
}
inline void User::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.User.identity)
}

// int32 type = 2;
inline void User::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t User::_internal_type() const {
  return _impl_.type_;
}
inline int32_t User::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.type)
  return _internal_type();
}
inline void User::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void User::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.User.type)
}

// int32 status = 3;
inline void User::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t User::_internal_status() const {
  return _impl_.status_;
}
inline int32_t User::status() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.status)
  return _internal_status();
}
inline void User::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void User::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.User.status)
}

// int64 update_ts = 5;
inline void User::clear_update_ts() {
  _impl_.update_ts_ = int64_t{0};
}
inline int64_t User::_internal_update_ts() const {
  return _impl_.update_ts_;
}
inline int64_t User::update_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.update_ts)
  return _internal_update_ts();
}
inline void User::_internal_set_update_ts(int64_t value) {
  
  _impl_.update_ts_ = value;
}
inline void User::set_update_ts(int64_t value) {
  _internal_set_update_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.User.update_ts)
}

// string password = 6;
inline void User::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& User::password() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.User.password)
}
inline std::string* User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.User.password)
  return _s;
}
inline const std::string& User::_internal_password() const {
  return _impl_.password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_password() {
  // @@protoc_insertion_point(field_release:v6.services.pub.User.password)
  return _impl_.password_.Release();
}
inline void User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.User.password)
}

// string name = 7;
inline void User::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& User::name() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.User.name)
}
inline std::string* User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:v6.services.pub.User.name)
  return _impl_.name_.Release();
}
inline void User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.User.name)
}

// string addon = 8;
inline void User::clear_addon() {
  _impl_.addon_.ClearToEmpty();
}
inline const std::string& User::addon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.addon)
  return _internal_addon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_addon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.User.addon)
}
inline std::string* User::mutable_addon() {
  std::string* _s = _internal_mutable_addon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.User.addon)
  return _s;
}
inline const std::string& User::_internal_addon() const {
  return _impl_.addon_.Get();
}
inline void User::_internal_set_addon(const std::string& value) {
  
  _impl_.addon_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_addon() {
  
  return _impl_.addon_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_addon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.User.addon)
  return _impl_.addon_.Release();
}
inline void User::set_allocated_addon(std::string* addon) {
  if (addon != nullptr) {
    
  } else {
    
  }
  _impl_.addon_.SetAllocated(addon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addon_.IsDefault()) {
    _impl_.addon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.User.addon)
}

// int64 create_ts = 9;
inline void User::clear_create_ts() {
  _impl_.create_ts_ = int64_t{0};
}
inline int64_t User::_internal_create_ts() const {
  return _impl_.create_ts_;
}
inline int64_t User::create_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.create_ts)
  return _internal_create_ts();
}
inline void User::_internal_set_create_ts(int64_t value) {
  
  _impl_.create_ts_ = value;
}
inline void User::set_create_ts(int64_t value) {
  _internal_set_create_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.User.create_ts)
}

// string hash = 10;
inline void User::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& User::hash() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.User.hash)
}
inline std::string* User::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.User.hash)
  return _s;
}
inline const std::string& User::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void User::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_hash() {
  // @@protoc_insertion_point(field_release:v6.services.pub.User.hash)
  return _impl_.hash_.Release();
}
inline void User::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.User.hash)
}

// string icon = 11;
inline void User::clear_icon() {
  _impl_.icon_.ClearToEmpty();
}
inline const std::string& User::icon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.User.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_icon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.icon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.User.icon)
}
inline std::string* User::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.User.icon)
  return _s;
}
inline const std::string& User::_internal_icon() const {
  return _impl_.icon_.Get();
}
inline void User::_internal_set_icon(const std::string& value) {
  
  _impl_.icon_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_icon() {
  
  return _impl_.icon_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_icon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.User.icon)
  return _impl_.icon_.Release();
}
inline void User::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  _impl_.icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.icon_.IsDefault()) {
    _impl_.icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.User.icon)
}

// -------------------------------------------------------------------

// LoginRequest

// string identity = 1;
inline void LoginRequest::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& LoginRequest::identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.identity)
}
inline std::string* LoginRequest::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.identity)
  return _s;
}
inline const std::string& LoginRequest::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void LoginRequest::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.identity)
  return _impl_.identity_.Release();
}
inline void LoginRequest::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.identity)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.password)
}

// string addon = 3;
inline void LoginRequest::clear_addon() {
  _impl_.addon_.ClearToEmpty();
}
inline const std::string& LoginRequest::addon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.addon)
  return _internal_addon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_addon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.addon)
}
inline std::string* LoginRequest::mutable_addon() {
  std::string* _s = _internal_mutable_addon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.addon)
  return _s;
}
inline const std::string& LoginRequest::_internal_addon() const {
  return _impl_.addon_.Get();
}
inline void LoginRequest::_internal_set_addon(const std::string& value) {
  
  _impl_.addon_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_addon() {
  
  return _impl_.addon_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_addon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.addon)
  return _impl_.addon_.Release();
}
inline void LoginRequest::set_allocated_addon(std::string* addon) {
  if (addon != nullptr) {
    
  } else {
    
  }
  _impl_.addon_.SetAllocated(addon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addon_.IsDefault()) {
    _impl_.addon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.addon)
}

// string input = 4;
inline void LoginRequest::clear_input() {
  _impl_.input_.ClearToEmpty();
}
inline const std::string& LoginRequest::input() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.input)
  return _internal_input();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_input(ArgT0&& arg0, ArgT... args) {
 
 _impl_.input_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.input)
}
inline std::string* LoginRequest::mutable_input() {
  std::string* _s = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.input)
  return _s;
}
inline const std::string& LoginRequest::_internal_input() const {
  return _impl_.input_.Get();
}
inline void LoginRequest::_internal_set_input(const std::string& value) {
  
  _impl_.input_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_input() {
  
  return _impl_.input_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_input() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.input)
  return _impl_.input_.Release();
}
inline void LoginRequest::set_allocated_input(std::string* input) {
  if (input != nullptr) {
    
  } else {
    
  }
  _impl_.input_.SetAllocated(input, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.input_.IsDefault()) {
    _impl_.input_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.input)
}

// string type = 5;
inline void LoginRequest::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& LoginRequest::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.type)
}
inline std::string* LoginRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.type)
  return _s;
}
inline const std::string& LoginRequest::_internal_type() const {
  return _impl_.type_.Get();
}
inline void LoginRequest::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_type() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.type)
  return _impl_.type_.Release();
}
inline void LoginRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.type)
}

// string callback = 6;
inline void LoginRequest::clear_callback() {
  _impl_.callback_.ClearToEmpty();
}
inline const std::string& LoginRequest::callback() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.callback)
  return _internal_callback();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_callback(ArgT0&& arg0, ArgT... args) {
 
 _impl_.callback_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.callback)
}
inline std::string* LoginRequest::mutable_callback() {
  std::string* _s = _internal_mutable_callback();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.callback)
  return _s;
}
inline const std::string& LoginRequest::_internal_callback() const {
  return _impl_.callback_.Get();
}
inline void LoginRequest::_internal_set_callback(const std::string& value) {
  
  _impl_.callback_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_callback() {
  
  return _impl_.callback_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_callback() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.callback)
  return _impl_.callback_.Release();
}
inline void LoginRequest::set_allocated_callback(std::string* callback) {
  if (callback != nullptr) {
    
  } else {
    
  }
  _impl_.callback_.SetAllocated(callback, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.callback_.IsDefault()) {
    _impl_.callback_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.callback)
}

// string return_url = 7;
inline void LoginRequest::clear_return_url() {
  _impl_.return_url_.ClearToEmpty();
}
inline const std::string& LoginRequest::return_url() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.return_url)
  return _internal_return_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_return_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.return_url)
}
inline std::string* LoginRequest::mutable_return_url() {
  std::string* _s = _internal_mutable_return_url();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.return_url)
  return _s;
}
inline const std::string& LoginRequest::_internal_return_url() const {
  return _impl_.return_url_.Get();
}
inline void LoginRequest::_internal_set_return_url(const std::string& value) {
  
  _impl_.return_url_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_return_url() {
  
  return _impl_.return_url_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_return_url() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.return_url)
  return _impl_.return_url_.Release();
}
inline void LoginRequest::set_allocated_return_url(std::string* return_url) {
  if (return_url != nullptr) {
    
  } else {
    
  }
  _impl_.return_url_.SetAllocated(return_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_url_.IsDefault()) {
    _impl_.return_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.return_url)
}

// int32 return_type = 8;
inline void LoginRequest::clear_return_type() {
  _impl_.return_type_ = 0;
}
inline int32_t LoginRequest::_internal_return_type() const {
  return _impl_.return_type_;
}
inline int32_t LoginRequest::return_type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.return_type)
  return _internal_return_type();
}
inline void LoginRequest::_internal_set_return_type(int32_t value) {
  
  _impl_.return_type_ = value;
}
inline void LoginRequest::set_return_type(int32_t value) {
  _internal_set_return_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.return_type)
}

// string captcha = 9;
inline void LoginRequest::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& LoginRequest::captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.captcha)
}
inline std::string* LoginRequest::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.captcha)
  return _s;
}
inline const std::string& LoginRequest::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void LoginRequest::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.captcha)
  return _impl_.captcha_.Release();
}
inline void LoginRequest::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.captcha)
}

// string state = 10;
inline void LoginRequest::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& LoginRequest::state() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.state)
}
inline std::string* LoginRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.state)
  return _s;
}
inline const std::string& LoginRequest::_internal_state() const {
  return _impl_.state_.Get();
}
inline void LoginRequest::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_state() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.state)
  return _impl_.state_.Release();
}
inline void LoginRequest::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.state)
}

// string country_code = 11;
inline void LoginRequest::clear_country_code() {
  _impl_.country_code_.ClearToEmpty();
}
inline const std::string& LoginRequest::country_code() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginRequest.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_country_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginRequest.country_code)
}
inline std::string* LoginRequest::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginRequest.country_code)
  return _s;
}
inline const std::string& LoginRequest::_internal_country_code() const {
  return _impl_.country_code_.Get();
}
inline void LoginRequest::_internal_set_country_code(const std::string& value) {
  
  _impl_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_country_code() {
  
  return _impl_.country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_country_code() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginRequest.country_code)
  return _impl_.country_code_.Release();
}
inline void LoginRequest::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    
  } else {
    
  }
  _impl_.country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginRequest.country_code)
}

// -------------------------------------------------------------------

// LoginResponse

// .v6.services.pub.Token token = 1;
inline bool LoginResponse::_internal_has_token() const {
  return this != internal_default_instance() && _impl_.token_ != nullptr;
}
inline bool LoginResponse::has_token() const {
  return _internal_has_token();
}
inline void LoginResponse::clear_token() {
  if (GetArenaForAllocation() == nullptr && _impl_.token_ != nullptr) {
    delete _impl_.token_;
  }
  _impl_.token_ = nullptr;
}
inline const ::v6::services::pub::Token& LoginResponse::_internal_token() const {
  const ::v6::services::pub::Token* p = _impl_.token_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::Token&>(
      ::v6::services::pub::_Token_default_instance_);
}
inline const ::v6::services::pub::Token& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginResponse.token)
  return _internal_token();
}
inline void LoginResponse::unsafe_arena_set_allocated_token(
    ::v6::services::pub::Token* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_);
  }
  _impl_.token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.LoginResponse.token)
}
inline ::v6::services::pub::Token* LoginResponse::release_token() {
  
  ::v6::services::pub::Token* temp = _impl_.token_;
  _impl_.token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::Token* LoginResponse::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginResponse.token)
  
  ::v6::services::pub::Token* temp = _impl_.token_;
  _impl_.token_ = nullptr;
  return temp;
}
inline ::v6::services::pub::Token* LoginResponse::_internal_mutable_token() {
  
  if (_impl_.token_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::Token>(GetArenaForAllocation());
    _impl_.token_ = p;
  }
  return _impl_.token_;
}
inline ::v6::services::pub::Token* LoginResponse::mutable_token() {
  ::v6::services::pub::Token* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginResponse.token)
  return _msg;
}
inline void LoginResponse::set_allocated_token(::v6::services::pub::Token* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.token_ = token;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginResponse.token)
}

// .v6.services.pub.User user = 2;
inline bool LoginResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool LoginResponse::has_user() const {
  return _internal_has_user();
}
inline void LoginResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::v6::services::pub::User& LoginResponse::_internal_user() const {
  const ::v6::services::pub::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::User&>(
      ::v6::services::pub::_User_default_instance_);
}
inline const ::v6::services::pub::User& LoginResponse::user() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginResponse.user)
  return _internal_user();
}
inline void LoginResponse::unsafe_arena_set_allocated_user(
    ::v6::services::pub::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.LoginResponse.user)
}
inline ::v6::services::pub::User* LoginResponse::release_user() {
  
  ::v6::services::pub::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::User* LoginResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginResponse.user)
  
  ::v6::services::pub::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::v6::services::pub::User* LoginResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::v6::services::pub::User* LoginResponse::mutable_user() {
  ::v6::services::pub::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginResponse.user)
  return _msg;
}
inline void LoginResponse::set_allocated_user(::v6::services::pub::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginResponse.user)
}

// .v6.services.pub.LastLoginResponse last_login = 3;
inline bool LoginResponse::_internal_has_last_login() const {
  return this != internal_default_instance() && _impl_.last_login_ != nullptr;
}
inline bool LoginResponse::has_last_login() const {
  return _internal_has_last_login();
}
inline void LoginResponse::clear_last_login() {
  if (GetArenaForAllocation() == nullptr && _impl_.last_login_ != nullptr) {
    delete _impl_.last_login_;
  }
  _impl_.last_login_ = nullptr;
}
inline const ::v6::services::pub::LastLoginResponse& LoginResponse::_internal_last_login() const {
  const ::v6::services::pub::LastLoginResponse* p = _impl_.last_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::LastLoginResponse&>(
      ::v6::services::pub::_LastLoginResponse_default_instance_);
}
inline const ::v6::services::pub::LastLoginResponse& LoginResponse::last_login() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginResponse.last_login)
  return _internal_last_login();
}
inline void LoginResponse::unsafe_arena_set_allocated_last_login(
    ::v6::services::pub::LastLoginResponse* last_login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_login_);
  }
  _impl_.last_login_ = last_login;
  if (last_login) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.LoginResponse.last_login)
}
inline ::v6::services::pub::LastLoginResponse* LoginResponse::release_last_login() {
  
  ::v6::services::pub::LastLoginResponse* temp = _impl_.last_login_;
  _impl_.last_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::LastLoginResponse* LoginResponse::unsafe_arena_release_last_login() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginResponse.last_login)
  
  ::v6::services::pub::LastLoginResponse* temp = _impl_.last_login_;
  _impl_.last_login_ = nullptr;
  return temp;
}
inline ::v6::services::pub::LastLoginResponse* LoginResponse::_internal_mutable_last_login() {
  
  if (_impl_.last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::LastLoginResponse>(GetArenaForAllocation());
    _impl_.last_login_ = p;
  }
  return _impl_.last_login_;
}
inline ::v6::services::pub::LastLoginResponse* LoginResponse::mutable_last_login() {
  ::v6::services::pub::LastLoginResponse* _msg = _internal_mutable_last_login();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginResponse.last_login)
  return _msg;
}
inline void LoginResponse::set_allocated_last_login(::v6::services::pub::LastLoginResponse* last_login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.last_login_;
  }
  if (last_login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(last_login);
    if (message_arena != submessage_arena) {
      last_login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_login, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_login_ = last_login;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginResponse.last_login)
}

// string state = 4;
inline void LoginResponse::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& LoginResponse::state() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LoginResponse.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LoginResponse.state)
}
inline std::string* LoginResponse::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LoginResponse.state)
  return _s;
}
inline const std::string& LoginResponse::_internal_state() const {
  return _impl_.state_.Get();
}
inline void LoginResponse::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_state() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LoginResponse.state)
  return _impl_.state_.Release();
}
inline void LoginResponse::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LoginResponse.state)
}

// -------------------------------------------------------------------

// LastLoginResponse

// string identity = 1;
inline void LastLoginResponse::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& LastLoginResponse::identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LastLoginResponse.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LastLoginResponse::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LastLoginResponse.identity)
}
inline std::string* LastLoginResponse::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LastLoginResponse.identity)
  return _s;
}
inline const std::string& LastLoginResponse::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void LastLoginResponse::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* LastLoginResponse::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* LastLoginResponse::release_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LastLoginResponse.identity)
  return _impl_.identity_.Release();
}
inline void LastLoginResponse::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LastLoginResponse.identity)
}

// int64 last_login_ts = 2;
inline void LastLoginResponse::clear_last_login_ts() {
  _impl_.last_login_ts_ = int64_t{0};
}
inline int64_t LastLoginResponse::_internal_last_login_ts() const {
  return _impl_.last_login_ts_;
}
inline int64_t LastLoginResponse::last_login_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LastLoginResponse.last_login_ts)
  return _internal_last_login_ts();
}
inline void LastLoginResponse::_internal_set_last_login_ts(int64_t value) {
  
  _impl_.last_login_ts_ = value;
}
inline void LastLoginResponse::set_last_login_ts(int64_t value) {
  _internal_set_last_login_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.LastLoginResponse.last_login_ts)
}

// string last_login_ip = 3;
inline void LastLoginResponse::clear_last_login_ip() {
  _impl_.last_login_ip_.ClearToEmpty();
}
inline const std::string& LastLoginResponse::last_login_ip() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LastLoginResponse.last_login_ip)
  return _internal_last_login_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LastLoginResponse::set_last_login_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_login_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LastLoginResponse.last_login_ip)
}
inline std::string* LastLoginResponse::mutable_last_login_ip() {
  std::string* _s = _internal_mutable_last_login_ip();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LastLoginResponse.last_login_ip)
  return _s;
}
inline const std::string& LastLoginResponse::_internal_last_login_ip() const {
  return _impl_.last_login_ip_.Get();
}
inline void LastLoginResponse::_internal_set_last_login_ip(const std::string& value) {
  
  _impl_.last_login_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* LastLoginResponse::_internal_mutable_last_login_ip() {
  
  return _impl_.last_login_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* LastLoginResponse::release_last_login_ip() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LastLoginResponse.last_login_ip)
  return _impl_.last_login_ip_.Release();
}
inline void LastLoginResponse::set_allocated_last_login_ip(std::string* last_login_ip) {
  if (last_login_ip != nullptr) {
    
  } else {
    
  }
  _impl_.last_login_ip_.SetAllocated(last_login_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_login_ip_.IsDefault()) {
    _impl_.last_login_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LastLoginResponse.last_login_ip)
}

// string last_login_device = 4;
inline void LastLoginResponse::clear_last_login_device() {
  _impl_.last_login_device_.ClearToEmpty();
}
inline const std::string& LastLoginResponse::last_login_device() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.LastLoginResponse.last_login_device)
  return _internal_last_login_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LastLoginResponse::set_last_login_device(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_login_device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.LastLoginResponse.last_login_device)
}
inline std::string* LastLoginResponse::mutable_last_login_device() {
  std::string* _s = _internal_mutable_last_login_device();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.LastLoginResponse.last_login_device)
  return _s;
}
inline const std::string& LastLoginResponse::_internal_last_login_device() const {
  return _impl_.last_login_device_.Get();
}
inline void LastLoginResponse::_internal_set_last_login_device(const std::string& value) {
  
  _impl_.last_login_device_.Set(value, GetArenaForAllocation());
}
inline std::string* LastLoginResponse::_internal_mutable_last_login_device() {
  
  return _impl_.last_login_device_.Mutable(GetArenaForAllocation());
}
inline std::string* LastLoginResponse::release_last_login_device() {
  // @@protoc_insertion_point(field_release:v6.services.pub.LastLoginResponse.last_login_device)
  return _impl_.last_login_device_.Release();
}
inline void LastLoginResponse::set_allocated_last_login_device(std::string* last_login_device) {
  if (last_login_device != nullptr) {
    
  } else {
    
  }
  _impl_.last_login_device_.SetAllocated(last_login_device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_login_device_.IsDefault()) {
    _impl_.last_login_device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.LastLoginResponse.last_login_device)
}

// -------------------------------------------------------------------

// Token

// string identity = 1;
inline void Token::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& Token::identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.identity)
}
inline std::string* Token::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.Token.identity)
  return _s;
}
inline const std::string& Token::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void Token::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.Token.identity)
  return _impl_.identity_.Release();
}
inline void Token::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.Token.identity)
}

// string user_identity = 2;
inline void Token::clear_user_identity() {
  _impl_.user_identity_.ClearToEmpty();
}
inline const std::string& Token::user_identity() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.user_identity)
  return _internal_user_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_user_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.user_identity)
}
inline std::string* Token::mutable_user_identity() {
  std::string* _s = _internal_mutable_user_identity();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.Token.user_identity)
  return _s;
}
inline const std::string& Token::_internal_user_identity() const {
  return _impl_.user_identity_.Get();
}
inline void Token::_internal_set_user_identity(const std::string& value) {
  
  _impl_.user_identity_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_user_identity() {
  
  return _impl_.user_identity_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_user_identity() {
  // @@protoc_insertion_point(field_release:v6.services.pub.Token.user_identity)
  return _impl_.user_identity_.Release();
}
inline void Token::set_allocated_user_identity(std::string* user_identity) {
  if (user_identity != nullptr) {
    
  } else {
    
  }
  _impl_.user_identity_.SetAllocated(user_identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_identity_.IsDefault()) {
    _impl_.user_identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.Token.user_identity)
}

// string device = 3;
inline void Token::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Token::device() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_device(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.device)
}
inline std::string* Token::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.Token.device)
  return _s;
}
inline const std::string& Token::_internal_device() const {
  return _impl_.device_.Get();
}
inline void Token::_internal_set_device(const std::string& value) {
  
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_device() {
  
  return _impl_.device_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_device() {
  // @@protoc_insertion_point(field_release:v6.services.pub.Token.device)
  return _impl_.device_.Release();
}
inline void Token::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  _impl_.device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.Token.device)
}

// int32 version = 4;
inline void Token::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t Token::_internal_version() const {
  return _impl_.version_;
}
inline int32_t Token::version() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.version)
  return _internal_version();
}
inline void Token::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void Token::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.version)
}

// string access_token = 5;
inline void Token::clear_access_token() {
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& Token::access_token() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_access_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.access_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.access_token)
}
inline std::string* Token::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.Token.access_token)
  return _s;
}
inline const std::string& Token::_internal_access_token() const {
  return _impl_.access_token_.Get();
}
inline void Token::_internal_set_access_token(const std::string& value) {
  
  _impl_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_access_token() {
  
  return _impl_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_access_token() {
  // @@protoc_insertion_point(field_release:v6.services.pub.Token.access_token)
  return _impl_.access_token_.Release();
}
inline void Token::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    
  } else {
    
  }
  _impl_.access_token_.SetAllocated(access_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.access_token_.IsDefault()) {
    _impl_.access_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.Token.access_token)
}

// string refresh_token = 6;
inline void Token::clear_refresh_token() {
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& Token::refresh_token() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.refresh_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.refresh_token)
}
inline std::string* Token::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.Token.refresh_token)
  return _s;
}
inline const std::string& Token::_internal_refresh_token() const {
  return _impl_.refresh_token_.Get();
}
inline void Token::_internal_set_refresh_token(const std::string& value) {
  
  _impl_.refresh_token_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_refresh_token() {
  
  return _impl_.refresh_token_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_refresh_token() {
  // @@protoc_insertion_point(field_release:v6.services.pub.Token.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void Token::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    
  } else {
    
  }
  _impl_.refresh_token_.SetAllocated(refresh_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.refresh_token_.IsDefault()) {
    _impl_.refresh_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.Token.refresh_token)
}

// int64 update_ts = 7;
inline void Token::clear_update_ts() {
  _impl_.update_ts_ = int64_t{0};
}
inline int64_t Token::_internal_update_ts() const {
  return _impl_.update_ts_;
}
inline int64_t Token::update_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.update_ts)
  return _internal_update_ts();
}
inline void Token::_internal_set_update_ts(int64_t value) {
  
  _impl_.update_ts_ = value;
}
inline void Token::set_update_ts(int64_t value) {
  _internal_set_update_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.update_ts)
}

// int64 access_token_expire_ts = 8;
inline void Token::clear_access_token_expire_ts() {
  _impl_.access_token_expire_ts_ = int64_t{0};
}
inline int64_t Token::_internal_access_token_expire_ts() const {
  return _impl_.access_token_expire_ts_;
}
inline int64_t Token::access_token_expire_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.access_token_expire_ts)
  return _internal_access_token_expire_ts();
}
inline void Token::_internal_set_access_token_expire_ts(int64_t value) {
  
  _impl_.access_token_expire_ts_ = value;
}
inline void Token::set_access_token_expire_ts(int64_t value) {
  _internal_set_access_token_expire_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.access_token_expire_ts)
}

// int64 refresh_token_expire_ts = 9;
inline void Token::clear_refresh_token_expire_ts() {
  _impl_.refresh_token_expire_ts_ = int64_t{0};
}
inline int64_t Token::_internal_refresh_token_expire_ts() const {
  return _impl_.refresh_token_expire_ts_;
}
inline int64_t Token::refresh_token_expire_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.Token.refresh_token_expire_ts)
  return _internal_refresh_token_expire_ts();
}
inline void Token::_internal_set_refresh_token_expire_ts(int64_t value) {
  
  _impl_.refresh_token_expire_ts_ = value;
}
inline void Token::set_refresh_token_expire_ts(int64_t value) {
  _internal_set_refresh_token_expire_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.Token.refresh_token_expire_ts)
}

// -------------------------------------------------------------------

// RegisterRequest

// string name = 1;
inline void RegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.RegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.RegisterRequest.name)
}
inline std::string* RegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.RegisterRequest.name)
  return _s;
}
inline const std::string& RegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:v6.services.pub.RegisterRequest.name)
  return _impl_.name_.Release();
}
inline void RegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.RegisterRequest.name)
}

// string password = 2;
inline void RegisterRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.RegisterRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:v6.services.pub.RegisterRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.RegisterRequest.password)
}

// string email = 5;
inline void RegisterRequest::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterRequest::email() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.RegisterRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.RegisterRequest.email)
}
inline std::string* RegisterRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.RegisterRequest.email)
  return _s;
}
inline const std::string& RegisterRequest::_internal_email() const {
  return _impl_.email_.Get();
}
inline void RegisterRequest::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_email() {
  // @@protoc_insertion_point(field_release:v6.services.pub.RegisterRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.RegisterRequest.email)
}

// string sms_captcha = 6;
inline void RegisterRequest::clear_sms_captcha() {
  _impl_.sms_captcha_.ClearToEmpty();
}
inline const std::string& RegisterRequest::sms_captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.RegisterRequest.sms_captcha)
  return _internal_sms_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_sms_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sms_captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.RegisterRequest.sms_captcha)
}
inline std::string* RegisterRequest::mutable_sms_captcha() {
  std::string* _s = _internal_mutable_sms_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.RegisterRequest.sms_captcha)
  return _s;
}
inline const std::string& RegisterRequest::_internal_sms_captcha() const {
  return _impl_.sms_captcha_.Get();
}
inline void RegisterRequest::_internal_set_sms_captcha(const std::string& value) {
  
  _impl_.sms_captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_sms_captcha() {
  
  return _impl_.sms_captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_sms_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.RegisterRequest.sms_captcha)
  return _impl_.sms_captcha_.Release();
}
inline void RegisterRequest::set_allocated_sms_captcha(std::string* sms_captcha) {
  if (sms_captcha != nullptr) {
    
  } else {
    
  }
  _impl_.sms_captcha_.SetAllocated(sms_captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sms_captcha_.IsDefault()) {
    _impl_.sms_captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.RegisterRequest.sms_captcha)
}

// string captcha = 3;
inline void RegisterRequest::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& RegisterRequest::captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.RegisterRequest.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.RegisterRequest.captcha)
}
inline std::string* RegisterRequest::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.RegisterRequest.captcha)
  return _s;
}
inline const std::string& RegisterRequest::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void RegisterRequest::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.RegisterRequest.captcha)
  return _impl_.captcha_.Release();
}
inline void RegisterRequest::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.RegisterRequest.captcha)
}

// -------------------------------------------------------------------

// SmsVeifyCodeSendRequest

// string captcha = 1;
inline void SmsVeifyCodeSendRequest::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendRequest::captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequest.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendRequest::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequest.captcha)
}
inline std::string* SmsVeifyCodeSendRequest::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendRequest.captcha)
  return _s;
}
inline const std::string& SmsVeifyCodeSendRequest::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void SmsVeifyCodeSendRequest::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequest::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequest::release_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendRequest.captcha)
  return _impl_.captcha_.Release();
}
inline void SmsVeifyCodeSendRequest::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendRequest.captcha)
}

// int32 type = 2;
inline void SmsVeifyCodeSendRequest::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t SmsVeifyCodeSendRequest::_internal_type() const {
  return _impl_.type_;
}
inline int32_t SmsVeifyCodeSendRequest::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequest.type)
  return _internal_type();
}
inline void SmsVeifyCodeSendRequest::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void SmsVeifyCodeSendRequest::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequest.type)
}

// string addon = 3;
inline void SmsVeifyCodeSendRequest::clear_addon() {
  _impl_.addon_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendRequest::addon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequest.addon)
  return _internal_addon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendRequest::set_addon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequest.addon)
}
inline std::string* SmsVeifyCodeSendRequest::mutable_addon() {
  std::string* _s = _internal_mutable_addon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendRequest.addon)
  return _s;
}
inline const std::string& SmsVeifyCodeSendRequest::_internal_addon() const {
  return _impl_.addon_.Get();
}
inline void SmsVeifyCodeSendRequest::_internal_set_addon(const std::string& value) {
  
  _impl_.addon_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequest::_internal_mutable_addon() {
  
  return _impl_.addon_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequest::release_addon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendRequest.addon)
  return _impl_.addon_.Release();
}
inline void SmsVeifyCodeSendRequest::set_allocated_addon(std::string* addon) {
  if (addon != nullptr) {
    
  } else {
    
  }
  _impl_.addon_.SetAllocated(addon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addon_.IsDefault()) {
    _impl_.addon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendRequest.addon)
}

// -------------------------------------------------------------------

// SmsVeifyCodeSendRequestNotUser

// string captcha = 1;
inline void SmsVeifyCodeSendRequestNotUser::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequestNotUser.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendRequestNotUser::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequestNotUser.captcha)
}
inline std::string* SmsVeifyCodeSendRequestNotUser::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendRequestNotUser.captcha)
  return _s;
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void SmsVeifyCodeSendRequestNotUser::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::release_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendRequestNotUser.captcha)
  return _impl_.captcha_.Release();
}
inline void SmsVeifyCodeSendRequestNotUser::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendRequestNotUser.captcha)
}

// int32 type = 2;
inline void SmsVeifyCodeSendRequestNotUser::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t SmsVeifyCodeSendRequestNotUser::_internal_type() const {
  return _impl_.type_;
}
inline int32_t SmsVeifyCodeSendRequestNotUser::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequestNotUser.type)
  return _internal_type();
}
inline void SmsVeifyCodeSendRequestNotUser::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void SmsVeifyCodeSendRequestNotUser::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequestNotUser.type)
}

// string addon = 3;
inline void SmsVeifyCodeSendRequestNotUser::clear_addon() {
  _impl_.addon_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::addon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequestNotUser.addon)
  return _internal_addon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendRequestNotUser::set_addon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequestNotUser.addon)
}
inline std::string* SmsVeifyCodeSendRequestNotUser::mutable_addon() {
  std::string* _s = _internal_mutable_addon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendRequestNotUser.addon)
  return _s;
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::_internal_addon() const {
  return _impl_.addon_.Get();
}
inline void SmsVeifyCodeSendRequestNotUser::_internal_set_addon(const std::string& value) {
  
  _impl_.addon_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::_internal_mutable_addon() {
  
  return _impl_.addon_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::release_addon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendRequestNotUser.addon)
  return _impl_.addon_.Release();
}
inline void SmsVeifyCodeSendRequestNotUser::set_allocated_addon(std::string* addon) {
  if (addon != nullptr) {
    
  } else {
    
  }
  _impl_.addon_.SetAllocated(addon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addon_.IsDefault()) {
    _impl_.addon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendRequestNotUser.addon)
}

// string country_code = 4;
inline void SmsVeifyCodeSendRequestNotUser::clear_country_code() {
  _impl_.country_code_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::country_code() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequestNotUser.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendRequestNotUser::set_country_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequestNotUser.country_code)
}
inline std::string* SmsVeifyCodeSendRequestNotUser::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendRequestNotUser.country_code)
  return _s;
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::_internal_country_code() const {
  return _impl_.country_code_.Get();
}
inline void SmsVeifyCodeSendRequestNotUser::_internal_set_country_code(const std::string& value) {
  
  _impl_.country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::_internal_mutable_country_code() {
  
  return _impl_.country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::release_country_code() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendRequestNotUser.country_code)
  return _impl_.country_code_.Release();
}
inline void SmsVeifyCodeSendRequestNotUser::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    
  } else {
    
  }
  _impl_.country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.country_code_.IsDefault()) {
    _impl_.country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendRequestNotUser.country_code)
}

// string phone = 5;
inline void SmsVeifyCodeSendRequestNotUser::clear_phone() {
  _impl_.phone_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::phone() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendRequestNotUser.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendRequestNotUser::set_phone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendRequestNotUser.phone)
}
inline std::string* SmsVeifyCodeSendRequestNotUser::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendRequestNotUser.phone)
  return _s;
}
inline const std::string& SmsVeifyCodeSendRequestNotUser::_internal_phone() const {
  return _impl_.phone_.Get();
}
inline void SmsVeifyCodeSendRequestNotUser::_internal_set_phone(const std::string& value) {
  
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::_internal_mutable_phone() {
  
  return _impl_.phone_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendRequestNotUser::release_phone() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendRequestNotUser.phone)
  return _impl_.phone_.Release();
}
inline void SmsVeifyCodeSendRequestNotUser::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  _impl_.phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendRequestNotUser.phone)
}

// -------------------------------------------------------------------

// SmsVeifyCodeSendResponse

// string captcha = 1;
inline void SmsVeifyCodeSendResponse::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendResponse::captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendResponse.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendResponse::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendResponse.captcha)
}
inline std::string* SmsVeifyCodeSendResponse::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendResponse.captcha)
  return _s;
}
inline const std::string& SmsVeifyCodeSendResponse::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void SmsVeifyCodeSendResponse::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendResponse::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendResponse::release_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendResponse.captcha)
  return _impl_.captcha_.Release();
}
inline void SmsVeifyCodeSendResponse::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendResponse.captcha)
}

// int32 type = 2;
inline void SmsVeifyCodeSendResponse::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t SmsVeifyCodeSendResponse::_internal_type() const {
  return _impl_.type_;
}
inline int32_t SmsVeifyCodeSendResponse::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendResponse.type)
  return _internal_type();
}
inline void SmsVeifyCodeSendResponse::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void SmsVeifyCodeSendResponse::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendResponse.type)
}

// string addon = 3;
inline void SmsVeifyCodeSendResponse::clear_addon() {
  _impl_.addon_.ClearToEmpty();
}
inline const std::string& SmsVeifyCodeSendResponse::addon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendResponse.addon)
  return _internal_addon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmsVeifyCodeSendResponse::set_addon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendResponse.addon)
}
inline std::string* SmsVeifyCodeSendResponse::mutable_addon() {
  std::string* _s = _internal_mutable_addon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.SmsVeifyCodeSendResponse.addon)
  return _s;
}
inline const std::string& SmsVeifyCodeSendResponse::_internal_addon() const {
  return _impl_.addon_.Get();
}
inline void SmsVeifyCodeSendResponse::_internal_set_addon(const std::string& value) {
  
  _impl_.addon_.Set(value, GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendResponse::_internal_mutable_addon() {
  
  return _impl_.addon_.Mutable(GetArenaForAllocation());
}
inline std::string* SmsVeifyCodeSendResponse::release_addon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.SmsVeifyCodeSendResponse.addon)
  return _impl_.addon_.Release();
}
inline void SmsVeifyCodeSendResponse::set_allocated_addon(std::string* addon) {
  if (addon != nullptr) {
    
  } else {
    
  }
  _impl_.addon_.SetAllocated(addon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addon_.IsDefault()) {
    _impl_.addon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.SmsVeifyCodeSendResponse.addon)
}

// int64 expire_ts = 4;
inline void SmsVeifyCodeSendResponse::clear_expire_ts() {
  _impl_.expire_ts_ = int64_t{0};
}
inline int64_t SmsVeifyCodeSendResponse::_internal_expire_ts() const {
  return _impl_.expire_ts_;
}
inline int64_t SmsVeifyCodeSendResponse::expire_ts() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.SmsVeifyCodeSendResponse.expire_ts)
  return _internal_expire_ts();
}
inline void SmsVeifyCodeSendResponse::_internal_set_expire_ts(int64_t value) {
  
  _impl_.expire_ts_ = value;
}
inline void SmsVeifyCodeSendResponse::set_expire_ts(int64_t value) {
  _internal_set_expire_ts(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.SmsVeifyCodeSendResponse.expire_ts)
}

// -------------------------------------------------------------------

// OauthTokenResponse

// string url = 1;
inline void OauthTokenResponse::clear_url() {
  _impl_.url_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::url() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.url)
}
inline std::string* OauthTokenResponse::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.url)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_url() const {
  return _impl_.url_.Get();
}
inline void OauthTokenResponse::_internal_set_url(const std::string& value) {
  
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_url() {
  
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_url() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.url)
  return _impl_.url_.Release();
}
inline void OauthTokenResponse::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.url)
}

// string addon = 2;
inline void OauthTokenResponse::clear_addon() {
  _impl_.addon_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::addon() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.addon)
  return _internal_addon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_addon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.addon)
}
inline std::string* OauthTokenResponse::mutable_addon() {
  std::string* _s = _internal_mutable_addon();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.addon)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_addon() const {
  return _impl_.addon_.Get();
}
inline void OauthTokenResponse::_internal_set_addon(const std::string& value) {
  
  _impl_.addon_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_addon() {
  
  return _impl_.addon_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_addon() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.addon)
  return _impl_.addon_.Release();
}
inline void OauthTokenResponse::set_allocated_addon(std::string* addon) {
  if (addon != nullptr) {
    
  } else {
    
  }
  _impl_.addon_.SetAllocated(addon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addon_.IsDefault()) {
    _impl_.addon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.addon)
}

// string input = 3;
inline void OauthTokenResponse::clear_input() {
  _impl_.input_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::input() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.input)
  return _internal_input();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_input(ArgT0&& arg0, ArgT... args) {
 
 _impl_.input_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.input)
}
inline std::string* OauthTokenResponse::mutable_input() {
  std::string* _s = _internal_mutable_input();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.input)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_input() const {
  return _impl_.input_.Get();
}
inline void OauthTokenResponse::_internal_set_input(const std::string& value) {
  
  _impl_.input_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_input() {
  
  return _impl_.input_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_input() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.input)
  return _impl_.input_.Release();
}
inline void OauthTokenResponse::set_allocated_input(std::string* input) {
  if (input != nullptr) {
    
  } else {
    
  }
  _impl_.input_.SetAllocated(input, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.input_.IsDefault()) {
    _impl_.input_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.input)
}

// string type = 4;
inline void OauthTokenResponse::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.type)
}
inline std::string* OauthTokenResponse::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.type)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_type() const {
  return _impl_.type_.Get();
}
inline void OauthTokenResponse::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_type() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.type)
  return _impl_.type_.Release();
}
inline void OauthTokenResponse::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.type)
}

// string callback = 5;
inline void OauthTokenResponse::clear_callback() {
  _impl_.callback_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::callback() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.callback)
  return _internal_callback();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_callback(ArgT0&& arg0, ArgT... args) {
 
 _impl_.callback_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.callback)
}
inline std::string* OauthTokenResponse::mutable_callback() {
  std::string* _s = _internal_mutable_callback();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.callback)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_callback() const {
  return _impl_.callback_.Get();
}
inline void OauthTokenResponse::_internal_set_callback(const std::string& value) {
  
  _impl_.callback_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_callback() {
  
  return _impl_.callback_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_callback() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.callback)
  return _impl_.callback_.Release();
}
inline void OauthTokenResponse::set_allocated_callback(std::string* callback) {
  if (callback != nullptr) {
    
  } else {
    
  }
  _impl_.callback_.SetAllocated(callback, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.callback_.IsDefault()) {
    _impl_.callback_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.callback)
}

// string return_url = 6;
inline void OauthTokenResponse::clear_return_url() {
  _impl_.return_url_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::return_url() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.return_url)
  return _internal_return_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_return_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.return_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.return_url)
}
inline std::string* OauthTokenResponse::mutable_return_url() {
  std::string* _s = _internal_mutable_return_url();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.return_url)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_return_url() const {
  return _impl_.return_url_.Get();
}
inline void OauthTokenResponse::_internal_set_return_url(const std::string& value) {
  
  _impl_.return_url_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_return_url() {
  
  return _impl_.return_url_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_return_url() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.return_url)
  return _impl_.return_url_.Release();
}
inline void OauthTokenResponse::set_allocated_return_url(std::string* return_url) {
  if (return_url != nullptr) {
    
  } else {
    
  }
  _impl_.return_url_.SetAllocated(return_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.return_url_.IsDefault()) {
    _impl_.return_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.return_url)
}

// int32 return_type = 7;
inline void OauthTokenResponse::clear_return_type() {
  _impl_.return_type_ = 0;
}
inline int32_t OauthTokenResponse::_internal_return_type() const {
  return _impl_.return_type_;
}
inline int32_t OauthTokenResponse::return_type() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.return_type)
  return _internal_return_type();
}
inline void OauthTokenResponse::_internal_set_return_type(int32_t value) {
  
  _impl_.return_type_ = value;
}
inline void OauthTokenResponse::set_return_type(int32_t value) {
  _internal_set_return_type(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.return_type)
}

// string captcha = 8;
inline void OauthTokenResponse::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::captcha() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.captcha)
}
inline std::string* OauthTokenResponse::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.captcha)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void OauthTokenResponse::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_captcha() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.captcha)
  return _impl_.captcha_.Release();
}
inline void OauthTokenResponse::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.captcha)
}

// string state = 9;
inline void OauthTokenResponse::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& OauthTokenResponse::state() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenResponse.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenResponse::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenResponse.state)
}
inline std::string* OauthTokenResponse::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenResponse.state)
  return _s;
}
inline const std::string& OauthTokenResponse::_internal_state() const {
  return _impl_.state_.Get();
}
inline void OauthTokenResponse::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenResponse::release_state() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenResponse.state)
  return _impl_.state_.Release();
}
inline void OauthTokenResponse::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenResponse.state)
}

// -------------------------------------------------------------------

// OauthTokenCheckResponse

// .v6.services.pub.LoginResponse login = 1;
inline bool OauthTokenCheckResponse::_internal_has_login() const {
  return this != internal_default_instance() && _impl_.login_ != nullptr;
}
inline bool OauthTokenCheckResponse::has_login() const {
  return _internal_has_login();
}
inline void OauthTokenCheckResponse::clear_login() {
  if (GetArenaForAllocation() == nullptr && _impl_.login_ != nullptr) {
    delete _impl_.login_;
  }
  _impl_.login_ = nullptr;
}
inline const ::v6::services::pub::LoginResponse& OauthTokenCheckResponse::_internal_login() const {
  const ::v6::services::pub::LoginResponse* p = _impl_.login_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::LoginResponse&>(
      ::v6::services::pub::_LoginResponse_default_instance_);
}
inline const ::v6::services::pub::LoginResponse& OauthTokenCheckResponse::login() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenCheckResponse.login)
  return _internal_login();
}
inline void OauthTokenCheckResponse::unsafe_arena_set_allocated_login(
    ::v6::services::pub::LoginResponse* login) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_);
  }
  _impl_.login_ = login;
  if (login) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.OauthTokenCheckResponse.login)
}
inline ::v6::services::pub::LoginResponse* OauthTokenCheckResponse::release_login() {
  
  ::v6::services::pub::LoginResponse* temp = _impl_.login_;
  _impl_.login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::LoginResponse* OauthTokenCheckResponse::unsafe_arena_release_login() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenCheckResponse.login)
  
  ::v6::services::pub::LoginResponse* temp = _impl_.login_;
  _impl_.login_ = nullptr;
  return temp;
}
inline ::v6::services::pub::LoginResponse* OauthTokenCheckResponse::_internal_mutable_login() {
  
  if (_impl_.login_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::LoginResponse>(GetArenaForAllocation());
    _impl_.login_ = p;
  }
  return _impl_.login_;
}
inline ::v6::services::pub::LoginResponse* OauthTokenCheckResponse::mutable_login() {
  ::v6::services::pub::LoginResponse* _msg = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenCheckResponse.login)
  return _msg;
}
inline void OauthTokenCheckResponse::set_allocated_login(::v6::services::pub::LoginResponse* login) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_;
  }
  if (login) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login);
    if (message_arena != submessage_arena) {
      login = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.login_ = login;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenCheckResponse.login)
}

// .v6.services.pub.OauthTokenResponse oauth = 2;
inline bool OauthTokenCheckResponse::_internal_has_oauth() const {
  return this != internal_default_instance() && _impl_.oauth_ != nullptr;
}
inline bool OauthTokenCheckResponse::has_oauth() const {
  return _internal_has_oauth();
}
inline void OauthTokenCheckResponse::clear_oauth() {
  if (GetArenaForAllocation() == nullptr && _impl_.oauth_ != nullptr) {
    delete _impl_.oauth_;
  }
  _impl_.oauth_ = nullptr;
}
inline const ::v6::services::pub::OauthTokenResponse& OauthTokenCheckResponse::_internal_oauth() const {
  const ::v6::services::pub::OauthTokenResponse* p = _impl_.oauth_;
  return p != nullptr ? *p : reinterpret_cast<const ::v6::services::pub::OauthTokenResponse&>(
      ::v6::services::pub::_OauthTokenResponse_default_instance_);
}
inline const ::v6::services::pub::OauthTokenResponse& OauthTokenCheckResponse::oauth() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenCheckResponse.oauth)
  return _internal_oauth();
}
inline void OauthTokenCheckResponse::unsafe_arena_set_allocated_oauth(
    ::v6::services::pub::OauthTokenResponse* oauth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oauth_);
  }
  _impl_.oauth_ = oauth;
  if (oauth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v6.services.pub.OauthTokenCheckResponse.oauth)
}
inline ::v6::services::pub::OauthTokenResponse* OauthTokenCheckResponse::release_oauth() {
  
  ::v6::services::pub::OauthTokenResponse* temp = _impl_.oauth_;
  _impl_.oauth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v6::services::pub::OauthTokenResponse* OauthTokenCheckResponse::unsafe_arena_release_oauth() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenCheckResponse.oauth)
  
  ::v6::services::pub::OauthTokenResponse* temp = _impl_.oauth_;
  _impl_.oauth_ = nullptr;
  return temp;
}
inline ::v6::services::pub::OauthTokenResponse* OauthTokenCheckResponse::_internal_mutable_oauth() {
  
  if (_impl_.oauth_ == nullptr) {
    auto* p = CreateMaybeMessage<::v6::services::pub::OauthTokenResponse>(GetArenaForAllocation());
    _impl_.oauth_ = p;
  }
  return _impl_.oauth_;
}
inline ::v6::services::pub::OauthTokenResponse* OauthTokenCheckResponse::mutable_oauth() {
  ::v6::services::pub::OauthTokenResponse* _msg = _internal_mutable_oauth();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenCheckResponse.oauth)
  return _msg;
}
inline void OauthTokenCheckResponse::set_allocated_oauth(::v6::services::pub::OauthTokenResponse* oauth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.oauth_;
  }
  if (oauth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oauth);
    if (message_arena != submessage_arena) {
      oauth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oauth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.oauth_ = oauth;
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenCheckResponse.oauth)
}

// int32 status = 3;
inline void OauthTokenCheckResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t OauthTokenCheckResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t OauthTokenCheckResponse::status() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenCheckResponse.status)
  return _internal_status();
}
inline void OauthTokenCheckResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void OauthTokenCheckResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenCheckResponse.status)
}

// string message = 4;
inline void OauthTokenCheckResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& OauthTokenCheckResponse::message() const {
  // @@protoc_insertion_point(field_get:v6.services.pub.OauthTokenCheckResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OauthTokenCheckResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v6.services.pub.OauthTokenCheckResponse.message)
}
inline std::string* OauthTokenCheckResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:v6.services.pub.OauthTokenCheckResponse.message)
  return _s;
}
inline const std::string& OauthTokenCheckResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void OauthTokenCheckResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* OauthTokenCheckResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* OauthTokenCheckResponse::release_message() {
  // @@protoc_insertion_point(field_release:v6.services.pub.OauthTokenCheckResponse.message)
  return _impl_.message_.Release();
}
inline void OauthTokenCheckResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v6.services.pub.OauthTokenCheckResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pub
}  // namespace services
}  // namespace v6

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_5fsvc_2eproto
